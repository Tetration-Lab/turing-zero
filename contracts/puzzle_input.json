{
  "language": "Solidity",
  "sources": {
    "src/Puzzle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\nimport \"./PlonkVK.sol\";\nimport \"forge-std/console2.sol\";\n\nstruct TapePuzzle {\n    address creator;\n    uint256 startTape;\n    uint256 endTape;\n    string name;\n}\n\ncontract Puzzle {\n    UltraVerifier public verifier;\n    uint256 currentPuzzleId = 0;\n    mapping(uint256 => TapePuzzle) public puzzles;\n    mapping(uint256 => address[]) public puzzleSolvers;\n    mapping(address => mapping(uint256 => bool)) public solvedPuzzles;\n    mapping(bytes32 => bool) public hashes;\n\n    constructor(UltraVerifier _verifier) {\n        verifier = _verifier;\n    }\n\n    function getPuzzles(\n        uint limit,\n        uint offset\n    ) public view returns (TapePuzzle[] memory) {\n        uint size = currentPuzzleId - offset > limit\n            ? limit\n            : currentPuzzleId - offset;\n        TapePuzzle[] memory result = new TapePuzzle[](size);\n        uint256 count = 0;\n        for (uint256 i = offset; i < (offset + size); i++) {\n            result[count] = puzzles[i];\n            count++;\n        }\n        return result;\n    }\n\n    function createPuzzle(\n        string calldata name,\n        uint startTape,\n        uint endTape\n    ) external returns (uint256 ret) {\n        puzzles[currentPuzzleId] = TapePuzzle({\n            creator: msg.sender,\n            startTape: startTape,\n            endTape: endTape,\n            name: name\n        });\n        ret = currentPuzzleId;\n        currentPuzzleId++;\n    }\n\n    function submitPuzzle(\n        uint256 puzzleId,\n        uint256 finalState,\n        bytes calldata proof\n    ) external {\n        bytes32[] memory input = new bytes32[](65);\n        for (uint256 i = 0; i < 32; i++) {\n            input[i] = bytes32(\n                uint256(uint8(puzzles[puzzleId].startTape >> (i * 8)))\n            );\n        }\n        for (uint256 i = 0; i < 32; i++) {\n            input[i + 32] = bytes32(\n                uint256(uint8(puzzles[puzzleId].endTape >> (i * 8)))\n            );\n        }\n        input[64] = bytes32(finalState);\n\n        // for (uint256 i = 0; i < 65; i++) {\n        //     console2.log(i, uint(input[i]));\n        // }\n\n        require(verifier.verify(proof, input), \"Invalid proof\");\n        require(!solvedPuzzles[msg.sender][puzzleId], \"Puzzle already solved\");\n        if (!hashes[keccak256(proof)]) {\n            hashes[keccak256(proof)] = true;\n            puzzleSolvers[puzzleId].push(msg.sender);\n            solvedPuzzles[msg.sender][puzzleId] = true;\n        } else {\n            revert(\"Proof already submitted\");\n        }\n    }\n}\n"
    },
    "src/PlonkVK.sol": {
      "content": "// Verification Key Hash: 3055b860942589a8f2e2d9fd2f04871bab965704d5ade417013a38d14879bac2\n// SPDX-License-Identifier: Apache-2.0\n// Copyright 2022 Aztec\npragma solidity >=0.8.4;\n\nlibrary UltraVerificationKey {\n    function verificationKeyHash() internal pure returns (bytes32) {\n        return\n            0x3055b860942589a8f2e2d9fd2f04871bab965704d5ade417013a38d14879bac2;\n    }\n\n    function loadVerificationKey(\n        uint256 _vk,\n        uint256 _omegaInverseLoc\n    ) internal pure {\n        assembly {\n            mstore(\n                add(_vk, 0x00),\n                0x0000000000000000000000000000000000000000000000000000000000010000\n            ) // vk.circuit_size\n            mstore(\n                add(_vk, 0x20),\n                0x0000000000000000000000000000000000000000000000000000000000000041\n            ) // vk.num_inputs\n            mstore(\n                add(_vk, 0x40),\n                0x00eeb2cb5981ed45649abebde081dcff16c8601de4347e7dd1628ba2daac43b7\n            ) // vk.work_root\n            mstore(\n                add(_vk, 0x60),\n                0x30641e0e92bebef818268d663bcad6dbcfd6c0149170f6d7d350b1b1fa6c1001\n            ) // vk.domain_inverse\n            mstore(\n                add(_vk, 0x80),\n                0x1fba7508437ba60d6d61a27b660837530062fc426d457e84f126b4ec4a2b19de\n            ) // vk.Q1.x\n            mstore(\n                add(_vk, 0xa0),\n                0x205e897847da271cc1bb07d422c5ebdcaf7dedb9858236b2c65af27dc85c32a5\n            ) // vk.Q1.y\n            mstore(\n                add(_vk, 0xc0),\n                0x22efc31e84dbc6cc8d565bd7ed8cf4c58e8cf7a850fbbb77db0b2887c79429ca\n            ) // vk.Q2.x\n            mstore(\n                add(_vk, 0xe0),\n                0x09ea5f3aae166c52350815d4edb2fa902579cc4a1da219923dd5daf6a215272e\n            ) // vk.Q2.y\n            mstore(\n                add(_vk, 0x100),\n                0x24db1fb9100db09515c84e0950d3c78b61996bab3f91c25488492637a226658c\n            ) // vk.Q3.x\n            mstore(\n                add(_vk, 0x120),\n                0x134a19b1eb52a6eec5c41deff3dfb74a3c03055cc784bbd900c64960cc1af9ed\n            ) // vk.Q3.y\n            mstore(\n                add(_vk, 0x140),\n                0x0e69dcb6f2298a72c0a6ac79ba4722d5626a0492ae3c016fad8de3cce04094e6\n            ) // vk.Q4.x\n            mstore(\n                add(_vk, 0x160),\n                0x12c431268489ee0bc8f51b5478ce9d127faa44a7839f63f2a65eb60e70134770\n            ) // vk.Q4.y\n            mstore(\n                add(_vk, 0x180),\n                0x0171512be03a2eef7fc2e2e35bc6ef309e92559bb1e5ce24538f14e32f8f775f\n            ) // vk.Q_M.x\n            mstore(\n                add(_vk, 0x1a0),\n                0x19f61c069397c93a428769f03e618d8eca34b4073f72fd88bf4d76e3ba4c9140\n            ) // vk.Q_M.y\n            mstore(\n                add(_vk, 0x1c0),\n                0x26f068f1319b8cd4d697bf7359cbc457541bc7919fd3019e0597c8a476732027\n            ) // vk.Q_C.x\n            mstore(\n                add(_vk, 0x1e0),\n                0x253eda72faaa1b4efab86fcb23b14a4274d6b77875b230009d924dc8c1d95c36\n            ) // vk.Q_C.y\n            mstore(\n                add(_vk, 0x200),\n                0x1dbda061813c007c280edcd548945ae5f341169d90fe9e474009a54974250977\n            ) // vk.Q_ARITHMETIC.x\n            mstore(\n                add(_vk, 0x220),\n                0x1973cc951d593b8acdcb887827a83a7cf9ff2fe4da300316b67eb014b2e92f94\n            ) // vk.Q_ARITHMETIC.y\n            mstore(\n                add(_vk, 0x240),\n                0x02304bfe932e37c72b41ffb4fff4a09f0d6290717958980139b6276ba97342f9\n            ) // vk.QSORT.x\n            mstore(\n                add(_vk, 0x260),\n                0x2e082ecd0736fcb5024426c4a4a946231d25c6b6202262dfa5f185437a63d610\n            ) // vk.QSORT.y\n            mstore(\n                add(_vk, 0x280),\n                0x21245d6c0a4d2ff12b21a825f39f30e8f8cf9b259448d111183e975828539576\n            ) // vk.Q_ELLIPTIC.x\n            mstore(\n                add(_vk, 0x2a0),\n                0x16a409532c8a1693536e93b6ce9920bfc2e6796e8dfe404675a0cdf6ee77ee7a\n            ) // vk.Q_ELLIPTIC.y\n            mstore(\n                add(_vk, 0x2c0),\n                0x022ba52b3567a0617ab34bdb984108dbe993d1e36a160d307ab4759565edb3b1\n            ) // vk.Q_AUX.x\n            mstore(\n                add(_vk, 0x2e0),\n                0x258c5d6f3a4a136a50cdfa03c95fb556cd5676e45e1eccaf8a7fed8612e34e26\n            ) // vk.Q_AUX.y\n            mstore(\n                add(_vk, 0x300),\n                0x23079e8fe98ebd1bc44da65a8889005bbd1d211239aa4257762619ed7c2ff0e1\n            ) // vk.SIGMA1.x\n            mstore(\n                add(_vk, 0x320),\n                0x22308332ded4ab11659e61a4a43a1a0ff4289a73bf513c12852ade4cb90147dd\n            ) // vk.SIGMA1.y\n            mstore(\n                add(_vk, 0x340),\n                0x1fc5820e342cab9486d0de859969f1c24de37c9fa83019496326186685303dfa\n            ) // vk.SIGMA2.x\n            mstore(\n                add(_vk, 0x360),\n                0x0dbea59e7f050a4e65382b5df73af1171e685425a54ba83f405ec1f801946092\n            ) // vk.SIGMA2.y\n            mstore(\n                add(_vk, 0x380),\n                0x2cc3af51705da21196d93cc582094b561ea9970492a97c621b2fb086b292f76b\n            ) // vk.SIGMA3.x\n            mstore(\n                add(_vk, 0x3a0),\n                0x18f1041e273c159b60eb9d4ca5c513ccce675c1ca42801e2594c680990b308fb\n            ) // vk.SIGMA3.y\n            mstore(\n                add(_vk, 0x3c0),\n                0x073266856212fc3695bc3c619e0df017b9096d24f0377f082093d9045961ebce\n            ) // vk.SIGMA4.x\n            mstore(\n                add(_vk, 0x3e0),\n                0x2a48b265cad1501b0a0ba81daf6bf3e09ec6c9fac77b674907910fd6033baa11\n            ) // vk.SIGMA4.y\n            mstore(\n                add(_vk, 0x400),\n                0x187e7e35d0116a6672b2670f83bf4f3257d2c5f95ca990943deb07f98e573f87\n            ) // vk.TABLE1.x\n            mstore(\n                add(_vk, 0x420),\n                0x01d2b37054e35124153a8d470749d60e55759ae7aa52dd33c253d7f49f31b768\n            ) // vk.TABLE1.y\n            mstore(\n                add(_vk, 0x440),\n                0x2043ac05206a2f580ed0a148adfaa26ef5516184126c9e67a8741e133af924cc\n            ) // vk.TABLE2.x\n            mstore(\n                add(_vk, 0x460),\n                0x2bf9b2f5f18eac63843fec205836e0e4cf77146523cb2b703ec9fd6f505b2a32\n            ) // vk.TABLE2.y\n            mstore(\n                add(_vk, 0x480),\n                0x01239374280500d61d963adeadc1cfef87ce7f19adb4f4f90c79f63d96468023\n            ) // vk.TABLE3.x\n            mstore(\n                add(_vk, 0x4a0),\n                0x0290f83ff91799507e620788f5072a71dd03df9c5605f9594bec63d1763724ca\n            ) // vk.TABLE3.y\n            mstore(\n                add(_vk, 0x4c0),\n                0x089ec02dcc6b3216cf9b4418e0827ad4b07d55d3ffa2b21da0743809bae4c2c8\n            ) // vk.TABLE4.x\n            mstore(\n                add(_vk, 0x4e0),\n                0x1c522d467e79e574c6bce1ef45cbb9598cc3a99de2de1ce994d0b657450b05b2\n            ) // vk.TABLE4.y\n            mstore(\n                add(_vk, 0x500),\n                0x2546faf6466689ca90de400304774d39e62e214c390b3a8673079fdbddecbd33\n            ) // vk.TABLE_TYPE.x\n            mstore(\n                add(_vk, 0x520),\n                0x1d6d3e828b1f70d792d184284184663d315a9e15827e8b76bcb8118293212f18\n            ) // vk.TABLE_TYPE.y\n            mstore(\n                add(_vk, 0x540),\n                0x2e8577f1b1b8663941a12ede0a2b4661c596e58b317084120c48803ae4cec421\n            ) // vk.ID1.x\n            mstore(\n                add(_vk, 0x560),\n                0x17aa56abfce46ad5c23d87d9a22595b9894d3dfd74ebb9e0b05d8645488cf253\n            ) // vk.ID1.y\n            mstore(\n                add(_vk, 0x580),\n                0x0ef3629b96eb71183ae73364b42bfbef6326a0020f6809ab4252ce4f115013c9\n            ) // vk.ID2.x\n            mstore(\n                add(_vk, 0x5a0),\n                0x225bbb161015d190a14e58f1a908bc356318294a214c9b3e21e8c862f47cf7bd\n            ) // vk.ID2.y\n            mstore(\n                add(_vk, 0x5c0),\n                0x071e2c0e6fc935ccd45add9634dfcdd39c65134169d60310dec52d5f6beef21b\n            ) // vk.ID3.x\n            mstore(\n                add(_vk, 0x5e0),\n                0x2eade8d3d1760c64b5bd73bee09e0eb7dddba5fd8904d7e4ffef0d22c41969f4\n            ) // vk.ID3.y\n            mstore(\n                add(_vk, 0x600),\n                0x0018ad128a79d1f7f5aab040263116fca503167d86f00c20e8f40202e9992364\n            ) // vk.ID4.x\n            mstore(\n                add(_vk, 0x620),\n                0x0e6c04ab0baf8f3130d480b70e8fa3058568bb88144776a362a230faccf4ad35\n            ) // vk.ID4.y\n            mstore(add(_vk, 0x640), 0x00) // vk.contains_recursive_proof\n            mstore(add(_vk, 0x660), 0) // vk.recursive_proof_public_input_indices\n            mstore(\n                add(_vk, 0x680),\n                0x260e01b251f6f1c7e7ff4e580791dee8ea51d87a358e038b4efe30fac09383c1\n            ) // vk.g2_x.X.c1\n            mstore(\n                add(_vk, 0x6a0),\n                0x0118c4d5b837bcc2bc89b5b398b5974e9f5944073b32078b7e231fec938883b0\n            ) // vk.g2_x.X.c0\n            mstore(\n                add(_vk, 0x6c0),\n                0x04fc6369f7110fe3d25156c1bb9a72859cf2a04641f99ba4ee413c80da6a5fe4\n            ) // vk.g2_x.Y.c1\n            mstore(\n                add(_vk, 0x6e0),\n                0x22febda3c0c0632a56475b4214e5615e11e6dd3f96e6cea2854a87d4dacc5e55\n            ) // vk.g2_x.Y.c0\n            mstore(\n                _omegaInverseLoc,\n                0x0b5d56b77fe704e8e92338c0082f37e091126414c830e4c6922d5ac802d842d4\n            ) // vk.work_root_inverse\n        }\n    }\n}\n\n/**\n * @title Ultra Plonk proof verification contract\n * @dev Top level Plonk proof verification contract, which allows Plonk proof to be verified\n */\nabstract contract BaseUltraVerifier {\n    // VERIFICATION KEY MEMORY LOCATIONS\n    uint256 internal constant N_LOC = 0x380;\n    uint256 internal constant NUM_INPUTS_LOC = 0x3a0;\n    uint256 internal constant OMEGA_LOC = 0x3c0;\n    uint256 internal constant DOMAIN_INVERSE_LOC = 0x3e0;\n    uint256 internal constant Q1_X_LOC = 0x400;\n    uint256 internal constant Q1_Y_LOC = 0x420;\n    uint256 internal constant Q2_X_LOC = 0x440;\n    uint256 internal constant Q2_Y_LOC = 0x460;\n    uint256 internal constant Q3_X_LOC = 0x480;\n    uint256 internal constant Q3_Y_LOC = 0x4a0;\n    uint256 internal constant Q4_X_LOC = 0x4c0;\n    uint256 internal constant Q4_Y_LOC = 0x4e0;\n    uint256 internal constant QM_X_LOC = 0x500;\n    uint256 internal constant QM_Y_LOC = 0x520;\n    uint256 internal constant QC_X_LOC = 0x540;\n    uint256 internal constant QC_Y_LOC = 0x560;\n    uint256 internal constant QARITH_X_LOC = 0x580;\n    uint256 internal constant QARITH_Y_LOC = 0x5a0;\n    uint256 internal constant QSORT_X_LOC = 0x5c0;\n    uint256 internal constant QSORT_Y_LOC = 0x5e0;\n    uint256 internal constant QELLIPTIC_X_LOC = 0x600;\n    uint256 internal constant QELLIPTIC_Y_LOC = 0x620;\n    uint256 internal constant QAUX_X_LOC = 0x640;\n    uint256 internal constant QAUX_Y_LOC = 0x660;\n    uint256 internal constant SIGMA1_X_LOC = 0x680;\n    uint256 internal constant SIGMA1_Y_LOC = 0x6a0;\n    uint256 internal constant SIGMA2_X_LOC = 0x6c0;\n    uint256 internal constant SIGMA2_Y_LOC = 0x6e0;\n    uint256 internal constant SIGMA3_X_LOC = 0x700;\n    uint256 internal constant SIGMA3_Y_LOC = 0x720;\n    uint256 internal constant SIGMA4_X_LOC = 0x740;\n    uint256 internal constant SIGMA4_Y_LOC = 0x760;\n    uint256 internal constant TABLE1_X_LOC = 0x780;\n    uint256 internal constant TABLE1_Y_LOC = 0x7a0;\n    uint256 internal constant TABLE2_X_LOC = 0x7c0;\n    uint256 internal constant TABLE2_Y_LOC = 0x7e0;\n    uint256 internal constant TABLE3_X_LOC = 0x800;\n    uint256 internal constant TABLE3_Y_LOC = 0x820;\n    uint256 internal constant TABLE4_X_LOC = 0x840;\n    uint256 internal constant TABLE4_Y_LOC = 0x860;\n    uint256 internal constant TABLE_TYPE_X_LOC = 0x880;\n    uint256 internal constant TABLE_TYPE_Y_LOC = 0x8a0;\n    uint256 internal constant ID1_X_LOC = 0x8c0;\n    uint256 internal constant ID1_Y_LOC = 0x8e0;\n    uint256 internal constant ID2_X_LOC = 0x900;\n    uint256 internal constant ID2_Y_LOC = 0x920;\n    uint256 internal constant ID3_X_LOC = 0x940;\n    uint256 internal constant ID3_Y_LOC = 0x960;\n    uint256 internal constant ID4_X_LOC = 0x980;\n    uint256 internal constant ID4_Y_LOC = 0x9a0;\n    uint256 internal constant CONTAINS_RECURSIVE_PROOF_LOC = 0x9c0;\n    uint256 internal constant RECURSIVE_PROOF_PUBLIC_INPUT_INDICES_LOC = 0x9e0;\n    uint256 internal constant G2X_X0_LOC = 0xa00;\n    uint256 internal constant G2X_X1_LOC = 0xa20;\n    uint256 internal constant G2X_Y0_LOC = 0xa40;\n    uint256 internal constant G2X_Y1_LOC = 0xa60;\n\n    // ### PROOF DATA MEMORY LOCATIONS\n    uint256 internal constant W1_X_LOC = 0x1200;\n    uint256 internal constant W1_Y_LOC = 0x1220;\n    uint256 internal constant W2_X_LOC = 0x1240;\n    uint256 internal constant W2_Y_LOC = 0x1260;\n    uint256 internal constant W3_X_LOC = 0x1280;\n    uint256 internal constant W3_Y_LOC = 0x12a0;\n    uint256 internal constant W4_X_LOC = 0x12c0;\n    uint256 internal constant W4_Y_LOC = 0x12e0;\n    uint256 internal constant S_X_LOC = 0x1300;\n    uint256 internal constant S_Y_LOC = 0x1320;\n    uint256 internal constant Z_X_LOC = 0x1340;\n    uint256 internal constant Z_Y_LOC = 0x1360;\n    uint256 internal constant Z_LOOKUP_X_LOC = 0x1380;\n    uint256 internal constant Z_LOOKUP_Y_LOC = 0x13a0;\n    uint256 internal constant T1_X_LOC = 0x13c0;\n    uint256 internal constant T1_Y_LOC = 0x13e0;\n    uint256 internal constant T2_X_LOC = 0x1400;\n    uint256 internal constant T2_Y_LOC = 0x1420;\n    uint256 internal constant T3_X_LOC = 0x1440;\n    uint256 internal constant T3_Y_LOC = 0x1460;\n    uint256 internal constant T4_X_LOC = 0x1480;\n    uint256 internal constant T4_Y_LOC = 0x14a0;\n\n    uint256 internal constant W1_EVAL_LOC = 0x1600;\n    uint256 internal constant W2_EVAL_LOC = 0x1620;\n    uint256 internal constant W3_EVAL_LOC = 0x1640;\n    uint256 internal constant W4_EVAL_LOC = 0x1660;\n    uint256 internal constant S_EVAL_LOC = 0x1680;\n    uint256 internal constant Z_EVAL_LOC = 0x16a0;\n    uint256 internal constant Z_LOOKUP_EVAL_LOC = 0x16c0;\n    uint256 internal constant Q1_EVAL_LOC = 0x16e0;\n    uint256 internal constant Q2_EVAL_LOC = 0x1700;\n    uint256 internal constant Q3_EVAL_LOC = 0x1720;\n    uint256 internal constant Q4_EVAL_LOC = 0x1740;\n    uint256 internal constant QM_EVAL_LOC = 0x1760;\n    uint256 internal constant QC_EVAL_LOC = 0x1780;\n    uint256 internal constant QARITH_EVAL_LOC = 0x17a0;\n    uint256 internal constant QSORT_EVAL_LOC = 0x17c0;\n    uint256 internal constant QELLIPTIC_EVAL_LOC = 0x17e0;\n    uint256 internal constant QAUX_EVAL_LOC = 0x1800;\n    uint256 internal constant TABLE1_EVAL_LOC = 0x1840;\n    uint256 internal constant TABLE2_EVAL_LOC = 0x1860;\n    uint256 internal constant TABLE3_EVAL_LOC = 0x1880;\n    uint256 internal constant TABLE4_EVAL_LOC = 0x18a0;\n    uint256 internal constant TABLE_TYPE_EVAL_LOC = 0x18c0;\n    uint256 internal constant ID1_EVAL_LOC = 0x18e0;\n    uint256 internal constant ID2_EVAL_LOC = 0x1900;\n    uint256 internal constant ID3_EVAL_LOC = 0x1920;\n    uint256 internal constant ID4_EVAL_LOC = 0x1940;\n    uint256 internal constant SIGMA1_EVAL_LOC = 0x1960;\n    uint256 internal constant SIGMA2_EVAL_LOC = 0x1980;\n    uint256 internal constant SIGMA3_EVAL_LOC = 0x19a0;\n    uint256 internal constant SIGMA4_EVAL_LOC = 0x19c0;\n    uint256 internal constant W1_OMEGA_EVAL_LOC = 0x19e0;\n    uint256 internal constant W2_OMEGA_EVAL_LOC = 0x2000;\n    uint256 internal constant W3_OMEGA_EVAL_LOC = 0x2020;\n    uint256 internal constant W4_OMEGA_EVAL_LOC = 0x2040;\n    uint256 internal constant S_OMEGA_EVAL_LOC = 0x2060;\n    uint256 internal constant Z_OMEGA_EVAL_LOC = 0x2080;\n    uint256 internal constant Z_LOOKUP_OMEGA_EVAL_LOC = 0x20a0;\n    uint256 internal constant TABLE1_OMEGA_EVAL_LOC = 0x20c0;\n    uint256 internal constant TABLE2_OMEGA_EVAL_LOC = 0x20e0;\n    uint256 internal constant TABLE3_OMEGA_EVAL_LOC = 0x2100;\n    uint256 internal constant TABLE4_OMEGA_EVAL_LOC = 0x2120;\n\n    uint256 internal constant PI_Z_X_LOC = 0x2300;\n    uint256 internal constant PI_Z_Y_LOC = 0x2320;\n    uint256 internal constant PI_Z_OMEGA_X_LOC = 0x2340;\n    uint256 internal constant PI_Z_OMEGA_Y_LOC = 0x2360;\n\n    // Used for elliptic widget. These are alias names for wire + shifted wire evaluations\n    uint256 internal constant X1_EVAL_LOC = W2_EVAL_LOC;\n    uint256 internal constant X2_EVAL_LOC = W1_OMEGA_EVAL_LOC;\n    uint256 internal constant X3_EVAL_LOC = W2_OMEGA_EVAL_LOC;\n    uint256 internal constant Y1_EVAL_LOC = W3_EVAL_LOC;\n    uint256 internal constant Y2_EVAL_LOC = W4_OMEGA_EVAL_LOC;\n    uint256 internal constant Y3_EVAL_LOC = W3_OMEGA_EVAL_LOC;\n    uint256 internal constant QBETA_LOC = Q3_EVAL_LOC;\n    uint256 internal constant QBETA_SQR_LOC = Q4_EVAL_LOC;\n    uint256 internal constant QSIGN_LOC = Q1_EVAL_LOC;\n\n    // ### CHALLENGES MEMORY OFFSETS\n\n    uint256 internal constant C_BETA_LOC = 0x2600;\n    uint256 internal constant C_GAMMA_LOC = 0x2620;\n    uint256 internal constant C_ALPHA_LOC = 0x2640;\n    uint256 internal constant C_ETA_LOC = 0x2660;\n    uint256 internal constant C_ETA_SQR_LOC = 0x2680;\n    uint256 internal constant C_ETA_CUBE_LOC = 0x26a0;\n\n    uint256 internal constant C_ZETA_LOC = 0x26c0;\n    uint256 internal constant C_CURRENT_LOC = 0x26e0;\n    uint256 internal constant C_V0_LOC = 0x2700;\n    uint256 internal constant C_V1_LOC = 0x2720;\n    uint256 internal constant C_V2_LOC = 0x2740;\n    uint256 internal constant C_V3_LOC = 0x2760;\n    uint256 internal constant C_V4_LOC = 0x2780;\n    uint256 internal constant C_V5_LOC = 0x27a0;\n    uint256 internal constant C_V6_LOC = 0x27c0;\n    uint256 internal constant C_V7_LOC = 0x27e0;\n    uint256 internal constant C_V8_LOC = 0x2800;\n    uint256 internal constant C_V9_LOC = 0x2820;\n    uint256 internal constant C_V10_LOC = 0x2840;\n    uint256 internal constant C_V11_LOC = 0x2860;\n    uint256 internal constant C_V12_LOC = 0x2880;\n    uint256 internal constant C_V13_LOC = 0x28a0;\n    uint256 internal constant C_V14_LOC = 0x28c0;\n    uint256 internal constant C_V15_LOC = 0x28e0;\n    uint256 internal constant C_V16_LOC = 0x2900;\n    uint256 internal constant C_V17_LOC = 0x2920;\n    uint256 internal constant C_V18_LOC = 0x2940;\n    uint256 internal constant C_V19_LOC = 0x2960;\n    uint256 internal constant C_V20_LOC = 0x2980;\n    uint256 internal constant C_V21_LOC = 0x29a0;\n    uint256 internal constant C_V22_LOC = 0x29c0;\n    uint256 internal constant C_V23_LOC = 0x29e0;\n    uint256 internal constant C_V24_LOC = 0x2a00;\n    uint256 internal constant C_V25_LOC = 0x2a20;\n    uint256 internal constant C_V26_LOC = 0x2a40;\n    uint256 internal constant C_V27_LOC = 0x2a60;\n    uint256 internal constant C_V28_LOC = 0x2a80;\n    uint256 internal constant C_V29_LOC = 0x2aa0;\n    uint256 internal constant C_V30_LOC = 0x2ac0;\n\n    uint256 internal constant C_U_LOC = 0x2b00;\n\n    // ### LOCAL VARIABLES MEMORY OFFSETS\n    uint256 internal constant DELTA_NUMERATOR_LOC = 0x3000;\n    uint256 internal constant DELTA_DENOMINATOR_LOC = 0x3020;\n    uint256 internal constant ZETA_POW_N_LOC = 0x3040;\n    uint256 internal constant PUBLIC_INPUT_DELTA_LOC = 0x3060;\n    uint256 internal constant ZERO_POLY_LOC = 0x3080;\n    uint256 internal constant L_START_LOC = 0x30a0;\n    uint256 internal constant L_END_LOC = 0x30c0;\n    uint256 internal constant R_ZERO_EVAL_LOC = 0x30e0;\n\n    uint256 internal constant PLOOKUP_DELTA_NUMERATOR_LOC = 0x3100;\n    uint256 internal constant PLOOKUP_DELTA_DENOMINATOR_LOC = 0x3120;\n    uint256 internal constant PLOOKUP_DELTA_LOC = 0x3140;\n\n    uint256 internal constant ACCUMULATOR_X_LOC = 0x3160;\n    uint256 internal constant ACCUMULATOR_Y_LOC = 0x3180;\n    uint256 internal constant ACCUMULATOR2_X_LOC = 0x31a0;\n    uint256 internal constant ACCUMULATOR2_Y_LOC = 0x31c0;\n    uint256 internal constant PAIRING_LHS_X_LOC = 0x31e0;\n    uint256 internal constant PAIRING_LHS_Y_LOC = 0x3200;\n    uint256 internal constant PAIRING_RHS_X_LOC = 0x3220;\n    uint256 internal constant PAIRING_RHS_Y_LOC = 0x3240;\n\n    // ### SUCCESS FLAG MEMORY LOCATIONS\n    uint256 internal constant GRAND_PRODUCT_SUCCESS_FLAG = 0x3300;\n    uint256 internal constant ARITHMETIC_TERM_SUCCESS_FLAG = 0x3020;\n    uint256 internal constant BATCH_OPENING_SUCCESS_FLAG = 0x3340;\n    uint256 internal constant OPENING_COMMITMENT_SUCCESS_FLAG = 0x3360;\n    uint256 internal constant PAIRING_PREAMBLE_SUCCESS_FLAG = 0x3380;\n    uint256 internal constant PAIRING_SUCCESS_FLAG = 0x33a0;\n    uint256 internal constant RESULT_FLAG = 0x33c0;\n\n    // misc stuff\n    uint256 internal constant OMEGA_INVERSE_LOC = 0x3400;\n    uint256 internal constant C_ALPHA_SQR_LOC = 0x3420;\n    uint256 internal constant C_ALPHA_CUBE_LOC = 0x3440;\n    uint256 internal constant C_ALPHA_QUAD_LOC = 0x3460;\n    uint256 internal constant C_ALPHA_BASE_LOC = 0x3480;\n\n    // ### RECURSION VARIABLE MEMORY LOCATIONS\n    uint256 internal constant RECURSIVE_P1_X_LOC = 0x3500;\n    uint256 internal constant RECURSIVE_P1_Y_LOC = 0x3520;\n    uint256 internal constant RECURSIVE_P2_X_LOC = 0x3540;\n    uint256 internal constant RECURSIVE_P2_Y_LOC = 0x3560;\n\n    uint256 internal constant PUBLIC_INPUTS_HASH_LOCATION = 0x3580;\n\n    // sub-identity storage\n    uint256 internal constant PERMUTATION_IDENTITY = 0x3600;\n    uint256 internal constant PLOOKUP_IDENTITY = 0x3620;\n    uint256 internal constant ARITHMETIC_IDENTITY = 0x3640;\n    uint256 internal constant SORT_IDENTITY = 0x3660;\n    uint256 internal constant ELLIPTIC_IDENTITY = 0x3680;\n    uint256 internal constant AUX_IDENTITY = 0x36a0;\n    uint256 internal constant AUX_NON_NATIVE_FIELD_EVALUATION = 0x36c0;\n    uint256 internal constant AUX_LIMB_ACCUMULATOR_EVALUATION = 0x36e0;\n    uint256 internal constant AUX_RAM_CONSISTENCY_EVALUATION = 0x3700;\n    uint256 internal constant AUX_ROM_CONSISTENCY_EVALUATION = 0x3720;\n    uint256 internal constant AUX_MEMORY_EVALUATION = 0x3740;\n\n    uint256 internal constant QUOTIENT_EVAL_LOC = 0x3760;\n    uint256 internal constant ZERO_POLY_INVERSE_LOC = 0x3780;\n\n    // when hashing public inputs we use memory at NU_CHALLENGE_INPUT_LOC_A, as the hash input size is unknown at compile time\n    uint256 internal constant NU_CHALLENGE_INPUT_LOC_A = 0x37a0;\n    uint256 internal constant NU_CHALLENGE_INPUT_LOC_B = 0x37c0;\n    uint256 internal constant NU_CHALLENGE_INPUT_LOC_C = 0x37e0;\n\n    bytes4 internal constant PUBLIC_INPUT_INVALID_BN128_G1_POINT_SELECTOR =\n        0xeba9f4a6;\n    bytes4 internal constant PUBLIC_INPUT_GE_P_SELECTOR = 0x374a972f;\n    bytes4 internal constant MOD_EXP_FAILURE_SELECTOR = 0xf894a7bc;\n    bytes4 internal constant EC_SCALAR_MUL_FAILURE_SELECTOR = 0xf755f369;\n    bytes4 internal constant PROOF_FAILURE_SELECTOR = 0x0711fcec;\n\n    uint256 internal constant ETA_INPUT_LENGTH = 0xc0; // W1, W2, W3 = 6 * 0x20 bytes\n\n    // We need to hash 41 field elements when generating the NU challenge\n    // w1, w2, w3, w4, s, z, z_lookup, q1, q2, q3, q4, qm, qc, qarith (14)\n    // qsort, qelliptic, qaux, sigma1, sigma2, sigma, sigma4, (7)\n    // table1, table2, table3, table4, tabletype, id1, id2, id3, id4, (9)\n    // w1_omega, w2_omega, w3_omega, w4_omega, s_omega, z_omega, z_lookup_omega, (7)\n    // table1_omega, table2_omega, table3_omega, table4_omega (4)\n    uint256 internal constant NU_INPUT_LENGTH = 0x520; // 0x520 = 41 * 0x20\n\n    // There are ELEVEN G1 group elements added into the transcript in the `beta` round, that we need to skip over\n    // W1, W2, W3, W4, S, Z, Z_LOOKUP, T1, T2, T3, T4\n    uint256 internal constant NU_CALLDATA_SKIP_LENGTH = 0x2c0; // 11 * 0x40 = 0x2c0\n\n    uint256 internal constant NEGATIVE_INVERSE_OF_2_MODULO_P =\n        0x183227397098d014dc2822db40c0ac2e9419f4243cdcb848a1f0fac9f8000000;\n    uint256 internal constant LIMB_SIZE = 0x100000000000000000; // 2<<68\n    uint256 internal constant SUBLIMB_SHIFT = 0x4000; // 2<<14\n\n    // y^2 = x^3 + ax + b\n    // for Grumpkin, a = 0 and b = -17. We use b in a custom gate relation that evaluates elliptic curve arithmetic\n    uint256 internal constant GRUMPKIN_CURVE_B_PARAMETER_NEGATED = 17;\n    error PUBLIC_INPUT_COUNT_INVALID(uint256 expected, uint256 actual);\n    error PUBLIC_INPUT_INVALID_BN128_G1_POINT();\n    error PUBLIC_INPUT_GE_P();\n    error MOD_EXP_FAILURE();\n    error EC_SCALAR_MUL_FAILURE();\n    error PROOF_FAILURE();\n\n    function getVerificationKeyHash() public pure virtual returns (bytes32);\n\n    function loadVerificationKey(\n        uint256 _vk,\n        uint256 _omegaInverseLoc\n    ) internal pure virtual;\n\n    /**\n     * @notice Verify a Ultra Plonk proof\n     * @param _proof - The serialized proof\n     * @param _publicInputs - An array of the public inputs\n     * @return True if proof is valid, reverts otherwise\n     */\n    function verify(\n        bytes calldata _proof,\n        bytes32[] calldata _publicInputs\n    ) external view returns (bool) {\n        loadVerificationKey(N_LOC, OMEGA_INVERSE_LOC);\n\n        uint256 requiredPublicInputCount;\n        assembly {\n            requiredPublicInputCount := mload(NUM_INPUTS_LOC)\n        }\n        if (requiredPublicInputCount != _publicInputs.length) {\n            revert PUBLIC_INPUT_COUNT_INVALID(\n                requiredPublicInputCount,\n                _publicInputs.length\n            );\n        }\n\n        assembly {\n            let\n                q\n            := 21888242871839275222246405745257275088696311157297823662689037894645226208583 // EC group order\n            let\n                p\n            := 21888242871839275222246405745257275088548364400416034343698204186575808495617 // Prime field order\n\n            /**\n             * LOAD PROOF FROM CALLDATA\n             */\n            {\n                let data_ptr := add(calldataload(0x04), 0x24)\n\n                mstore(W1_Y_LOC, mod(calldataload(data_ptr), q))\n                mstore(W1_X_LOC, mod(calldataload(add(data_ptr, 0x20)), q))\n\n                mstore(W2_Y_LOC, mod(calldataload(add(data_ptr, 0x40)), q))\n                mstore(W2_X_LOC, mod(calldataload(add(data_ptr, 0x60)), q))\n\n                mstore(W3_Y_LOC, mod(calldataload(add(data_ptr, 0x80)), q))\n                mstore(W3_X_LOC, mod(calldataload(add(data_ptr, 0xa0)), q))\n\n                mstore(W4_Y_LOC, mod(calldataload(add(data_ptr, 0xc0)), q))\n                mstore(W4_X_LOC, mod(calldataload(add(data_ptr, 0xe0)), q))\n\n                mstore(S_Y_LOC, mod(calldataload(add(data_ptr, 0x100)), q))\n                mstore(S_X_LOC, mod(calldataload(add(data_ptr, 0x120)), q))\n                mstore(Z_Y_LOC, mod(calldataload(add(data_ptr, 0x140)), q))\n                mstore(Z_X_LOC, mod(calldataload(add(data_ptr, 0x160)), q))\n                mstore(\n                    Z_LOOKUP_Y_LOC,\n                    mod(calldataload(add(data_ptr, 0x180)), q)\n                )\n                mstore(\n                    Z_LOOKUP_X_LOC,\n                    mod(calldataload(add(data_ptr, 0x1a0)), q)\n                )\n                mstore(T1_Y_LOC, mod(calldataload(add(data_ptr, 0x1c0)), q))\n                mstore(T1_X_LOC, mod(calldataload(add(data_ptr, 0x1e0)), q))\n\n                mstore(T2_Y_LOC, mod(calldataload(add(data_ptr, 0x200)), q))\n                mstore(T2_X_LOC, mod(calldataload(add(data_ptr, 0x220)), q))\n\n                mstore(T3_Y_LOC, mod(calldataload(add(data_ptr, 0x240)), q))\n                mstore(T3_X_LOC, mod(calldataload(add(data_ptr, 0x260)), q))\n\n                mstore(T4_Y_LOC, mod(calldataload(add(data_ptr, 0x280)), q))\n                mstore(T4_X_LOC, mod(calldataload(add(data_ptr, 0x2a0)), q))\n\n                mstore(W1_EVAL_LOC, mod(calldataload(add(data_ptr, 0x2c0)), p))\n                mstore(W2_EVAL_LOC, mod(calldataload(add(data_ptr, 0x2e0)), p))\n                mstore(W3_EVAL_LOC, mod(calldataload(add(data_ptr, 0x300)), p))\n                mstore(W4_EVAL_LOC, mod(calldataload(add(data_ptr, 0x320)), p))\n                mstore(S_EVAL_LOC, mod(calldataload(add(data_ptr, 0x340)), p))\n                mstore(Z_EVAL_LOC, mod(calldataload(add(data_ptr, 0x360)), p))\n                mstore(\n                    Z_LOOKUP_EVAL_LOC,\n                    mod(calldataload(add(data_ptr, 0x380)), p)\n                )\n                mstore(Q1_EVAL_LOC, mod(calldataload(add(data_ptr, 0x3a0)), p))\n                mstore(Q2_EVAL_LOC, mod(calldataload(add(data_ptr, 0x3c0)), p))\n                mstore(Q3_EVAL_LOC, mod(calldataload(add(data_ptr, 0x3e0)), p))\n                mstore(Q4_EVAL_LOC, mod(calldataload(add(data_ptr, 0x400)), p))\n                mstore(QM_EVAL_LOC, mod(calldataload(add(data_ptr, 0x420)), p))\n                mstore(QC_EVAL_LOC, mod(calldataload(add(data_ptr, 0x440)), p))\n                mstore(\n                    QARITH_EVAL_LOC,\n                    mod(calldataload(add(data_ptr, 0x460)), p)\n                )\n                mstore(\n                    QSORT_EVAL_LOC,\n                    mod(calldataload(add(data_ptr, 0x480)), p)\n                )\n                mstore(\n                    QELLIPTIC_EVAL_LOC,\n                    mod(calldataload(add(data_ptr, 0x4a0)), p)\n                )\n                mstore(\n                    QAUX_EVAL_LOC,\n                    mod(calldataload(add(data_ptr, 0x4c0)), p)\n                )\n\n                mstore(\n                    SIGMA1_EVAL_LOC,\n                    mod(calldataload(add(data_ptr, 0x4e0)), p)\n                )\n                mstore(\n                    SIGMA2_EVAL_LOC,\n                    mod(calldataload(add(data_ptr, 0x500)), p)\n                )\n\n                mstore(\n                    SIGMA3_EVAL_LOC,\n                    mod(calldataload(add(data_ptr, 0x520)), p)\n                )\n                mstore(\n                    SIGMA4_EVAL_LOC,\n                    mod(calldataload(add(data_ptr, 0x540)), p)\n                )\n\n                mstore(\n                    TABLE1_EVAL_LOC,\n                    mod(calldataload(add(data_ptr, 0x560)), p)\n                )\n                mstore(\n                    TABLE2_EVAL_LOC,\n                    mod(calldataload(add(data_ptr, 0x580)), p)\n                )\n                mstore(\n                    TABLE3_EVAL_LOC,\n                    mod(calldataload(add(data_ptr, 0x5a0)), p)\n                )\n                mstore(\n                    TABLE4_EVAL_LOC,\n                    mod(calldataload(add(data_ptr, 0x5c0)), p)\n                )\n                mstore(\n                    TABLE_TYPE_EVAL_LOC,\n                    mod(calldataload(add(data_ptr, 0x5e0)), p)\n                )\n\n                mstore(ID1_EVAL_LOC, mod(calldataload(add(data_ptr, 0x600)), p))\n                mstore(ID2_EVAL_LOC, mod(calldataload(add(data_ptr, 0x620)), p))\n                mstore(ID3_EVAL_LOC, mod(calldataload(add(data_ptr, 0x640)), p))\n                mstore(ID4_EVAL_LOC, mod(calldataload(add(data_ptr, 0x660)), p))\n\n                mstore(\n                    W1_OMEGA_EVAL_LOC,\n                    mod(calldataload(add(data_ptr, 0x680)), p)\n                )\n                mstore(\n                    W2_OMEGA_EVAL_LOC,\n                    mod(calldataload(add(data_ptr, 0x6a0)), p)\n                )\n                mstore(\n                    W3_OMEGA_EVAL_LOC,\n                    mod(calldataload(add(data_ptr, 0x6c0)), p)\n                )\n                mstore(\n                    W4_OMEGA_EVAL_LOC,\n                    mod(calldataload(add(data_ptr, 0x6e0)), p)\n                )\n                mstore(\n                    S_OMEGA_EVAL_LOC,\n                    mod(calldataload(add(data_ptr, 0x700)), p)\n                )\n\n                mstore(\n                    Z_OMEGA_EVAL_LOC,\n                    mod(calldataload(add(data_ptr, 0x720)), p)\n                )\n\n                mstore(\n                    Z_LOOKUP_OMEGA_EVAL_LOC,\n                    mod(calldataload(add(data_ptr, 0x740)), p)\n                )\n                mstore(\n                    TABLE1_OMEGA_EVAL_LOC,\n                    mod(calldataload(add(data_ptr, 0x760)), p)\n                )\n                mstore(\n                    TABLE2_OMEGA_EVAL_LOC,\n                    mod(calldataload(add(data_ptr, 0x780)), p)\n                )\n                mstore(\n                    TABLE3_OMEGA_EVAL_LOC,\n                    mod(calldataload(add(data_ptr, 0x7a0)), p)\n                )\n                mstore(\n                    TABLE4_OMEGA_EVAL_LOC,\n                    mod(calldataload(add(data_ptr, 0x7c0)), p)\n                )\n\n                mstore(PI_Z_Y_LOC, mod(calldataload(add(data_ptr, 0x7e0)), q))\n                mstore(PI_Z_X_LOC, mod(calldataload(add(data_ptr, 0x800)), q))\n\n                mstore(\n                    PI_Z_OMEGA_Y_LOC,\n                    mod(calldataload(add(data_ptr, 0x820)), q)\n                )\n                mstore(\n                    PI_Z_OMEGA_X_LOC,\n                    mod(calldataload(add(data_ptr, 0x840)), q)\n                )\n            }\n\n            /**\n             * LOAD RECURSIVE PROOF INTO MEMORY\n             */\n            {\n                if mload(CONTAINS_RECURSIVE_PROOF_LOC) {\n                    let public_inputs_ptr := add(calldataload(0x24), 0x24)\n                    let index_counter := add(\n                        shl(5, mload(RECURSIVE_PROOF_PUBLIC_INPUT_INDICES_LOC)),\n                        public_inputs_ptr\n                    )\n\n                    let x0 := calldataload(index_counter)\n                    x0 := add(\n                        x0,\n                        shl(68, calldataload(add(index_counter, 0x20)))\n                    )\n                    x0 := add(\n                        x0,\n                        shl(136, calldataload(add(index_counter, 0x40)))\n                    )\n                    x0 := add(\n                        x0,\n                        shl(204, calldataload(add(index_counter, 0x60)))\n                    )\n                    let y0 := calldataload(add(index_counter, 0x80))\n                    y0 := add(\n                        y0,\n                        shl(68, calldataload(add(index_counter, 0xa0)))\n                    )\n                    y0 := add(\n                        y0,\n                        shl(136, calldataload(add(index_counter, 0xc0)))\n                    )\n                    y0 := add(\n                        y0,\n                        shl(204, calldataload(add(index_counter, 0xe0)))\n                    )\n                    let x1 := calldataload(add(index_counter, 0x100))\n                    x1 := add(\n                        x1,\n                        shl(68, calldataload(add(index_counter, 0x120)))\n                    )\n                    x1 := add(\n                        x1,\n                        shl(136, calldataload(add(index_counter, 0x140)))\n                    )\n                    x1 := add(\n                        x1,\n                        shl(204, calldataload(add(index_counter, 0x160)))\n                    )\n                    let y1 := calldataload(add(index_counter, 0x180))\n                    y1 := add(\n                        y1,\n                        shl(68, calldataload(add(index_counter, 0x1a0)))\n                    )\n                    y1 := add(\n                        y1,\n                        shl(136, calldataload(add(index_counter, 0x1c0)))\n                    )\n                    y1 := add(\n                        y1,\n                        shl(204, calldataload(add(index_counter, 0x1e0)))\n                    )\n                    mstore(RECURSIVE_P1_X_LOC, x0)\n                    mstore(RECURSIVE_P1_Y_LOC, y0)\n                    mstore(RECURSIVE_P2_X_LOC, x1)\n                    mstore(RECURSIVE_P2_Y_LOC, y1)\n\n                    // validate these are valid bn128 G1 points\n                    if iszero(\n                        and(\n                            and(lt(x0, q), lt(x1, q)),\n                            and(lt(y0, q), lt(y1, q))\n                        )\n                    ) {\n                        mstore(\n                            0x00,\n                            PUBLIC_INPUT_INVALID_BN128_G1_POINT_SELECTOR\n                        )\n                        revert(0x00, 0x04)\n                    }\n                }\n            }\n\n            {\n                /**\n                 * Generate initial challenge\n                 */\n                mstore(0x00, shl(224, mload(N_LOC)))\n                mstore(0x04, shl(224, mload(NUM_INPUTS_LOC)))\n                let challenge := keccak256(0x00, 0x08)\n\n                /**\n                 * Generate eta challenge\n                 */\n                mstore(PUBLIC_INPUTS_HASH_LOCATION, challenge)\n                // The public input location is stored at 0x24, we then add 0x24 to skip selector and the length of public inputs\n                let public_inputs_start := add(calldataload(0x24), 0x24)\n                // copy the public inputs over\n                let public_input_size := mul(mload(NUM_INPUTS_LOC), 0x20)\n                calldatacopy(\n                    add(PUBLIC_INPUTS_HASH_LOCATION, 0x20),\n                    public_inputs_start,\n                    public_input_size\n                )\n\n                // copy W1, W2, W3 into challenge. Each point is 0x40 bytes, so load 0xc0 = 3 * 0x40 bytes (ETA input length)\n                let w_start := add(calldataload(0x04), 0x24)\n                calldatacopy(\n                    add(\n                        add(PUBLIC_INPUTS_HASH_LOCATION, 0x20),\n                        public_input_size\n                    ),\n                    w_start,\n                    ETA_INPUT_LENGTH\n                )\n\n                // Challenge is the old challenge + public inputs + W1, W2, W3 (0x20 + public_input_size + 0xc0)\n                let challenge_bytes_size := add(\n                    0x20,\n                    add(public_input_size, ETA_INPUT_LENGTH)\n                )\n\n                challenge := keccak256(\n                    PUBLIC_INPUTS_HASH_LOCATION,\n                    challenge_bytes_size\n                )\n                {\n                    let eta := mod(challenge, p)\n                    mstore(C_ETA_LOC, eta)\n                    mstore(C_ETA_SQR_LOC, mulmod(eta, eta, p))\n                    mstore(C_ETA_CUBE_LOC, mulmod(mload(C_ETA_SQR_LOC), eta, p))\n                }\n\n                /**\n                 * Generate beta challenge\n                 */\n                mstore(0x00, challenge)\n                mstore(0x20, mload(W4_Y_LOC))\n                mstore(0x40, mload(W4_X_LOC))\n                mstore(0x60, mload(S_Y_LOC))\n                mstore(0x80, mload(S_X_LOC))\n                challenge := keccak256(0x00, 0xa0)\n                mstore(C_BETA_LOC, mod(challenge, p))\n\n                /**\n                 * Generate gamma challenge\n                 */\n                mstore(0x00, challenge)\n                mstore8(0x20, 0x01)\n                challenge := keccak256(0x00, 0x21)\n                mstore(C_GAMMA_LOC, mod(challenge, p))\n\n                /**\n                 * Generate alpha challenge\n                 */\n                mstore(0x00, challenge)\n                mstore(0x20, mload(Z_Y_LOC))\n                mstore(0x40, mload(Z_X_LOC))\n                mstore(0x60, mload(Z_LOOKUP_Y_LOC))\n                mstore(0x80, mload(Z_LOOKUP_X_LOC))\n                challenge := keccak256(0x00, 0xa0)\n                mstore(C_ALPHA_LOC, mod(challenge, p))\n\n                /**\n                 * Compute and store some powers of alpha for future computations\n                 */\n                let alpha := mload(C_ALPHA_LOC)\n                mstore(C_ALPHA_SQR_LOC, mulmod(alpha, alpha, p))\n                mstore(\n                    C_ALPHA_CUBE_LOC,\n                    mulmod(mload(C_ALPHA_SQR_LOC), alpha, p)\n                )\n                mstore(\n                    C_ALPHA_QUAD_LOC,\n                    mulmod(mload(C_ALPHA_CUBE_LOC), alpha, p)\n                )\n                mstore(C_ALPHA_BASE_LOC, alpha)\n\n                /**\n                 * Generate zeta challenge\n                 */\n                mstore(0x00, challenge)\n                mstore(0x20, mload(T1_Y_LOC))\n                mstore(0x40, mload(T1_X_LOC))\n                mstore(0x60, mload(T2_Y_LOC))\n                mstore(0x80, mload(T2_X_LOC))\n                mstore(0xa0, mload(T3_Y_LOC))\n                mstore(0xc0, mload(T3_X_LOC))\n                mstore(0xe0, mload(T4_Y_LOC))\n                mstore(0x100, mload(T4_X_LOC))\n\n                challenge := keccak256(0x00, 0x120)\n\n                mstore(C_ZETA_LOC, mod(challenge, p))\n                mstore(C_CURRENT_LOC, challenge)\n            }\n\n            /**\n             * EVALUATE FIELD OPERATIONS\n             */\n\n            /**\n             * COMPUTE PUBLIC INPUT DELTA\n             * ΔPI = ∏ᵢ∈ℓ(wᵢ + β σ(i) + γ) / ∏ᵢ∈ℓ(wᵢ + β σ'(i) + γ)\n             */\n            {\n                let beta := mload(C_BETA_LOC) // β\n                let gamma := mload(C_GAMMA_LOC) // γ\n                let work_root := mload(OMEGA_LOC) // ω\n                let numerator_value := 1\n                let denominator_value := 1\n\n                let p_clone := p // move p to the front of the stack\n                let valid_inputs := true\n\n                // Load the starting point of the public inputs (jump over the selector and the length of public inputs [0x24])\n                let public_inputs_ptr := add(calldataload(0x24), 0x24)\n\n                // endpoint_ptr = public_inputs_ptr + num_inputs * 0x20. // every public input is 0x20 bytes\n                let endpoint_ptr := add(\n                    public_inputs_ptr,\n                    mul(mload(NUM_INPUTS_LOC), 0x20)\n                )\n\n                // root_1 = β * 0x05\n                let root_1 := mulmod(beta, 0x05, p_clone) // k1.β\n                // root_2 = β * 0x0c\n                let root_2 := mulmod(beta, 0x0c, p_clone)\n                // @note 0x05 + 0x07 == 0x0c == external coset generator\n\n                for {\n\n                } lt(public_inputs_ptr, endpoint_ptr) {\n                    public_inputs_ptr := add(public_inputs_ptr, 0x20)\n                } {\n                    /**\n                     * input = public_input[i]\n                     * valid_inputs &= input < p\n                     * temp = input + gamma\n                     * numerator_value *= (β.σ(i) + wᵢ + γ)  // σ(i) = 0x05.ωⁱ\n                     * denominator_value *= (β.σ'(i) + wᵢ + γ) // σ'(i) = 0x0c.ωⁱ\n                     * root_1 *= ω\n                     * root_2 *= ω\n                     */\n\n                    let input := calldataload(public_inputs_ptr)\n                    valid_inputs := and(valid_inputs, lt(input, p_clone))\n                    let temp := addmod(input, gamma, p_clone)\n\n                    numerator_value := mulmod(\n                        numerator_value,\n                        add(root_1, temp),\n                        p_clone\n                    )\n                    denominator_value := mulmod(\n                        denominator_value,\n                        add(root_2, temp),\n                        p_clone\n                    )\n\n                    root_1 := mulmod(root_1, work_root, p_clone)\n                    root_2 := mulmod(root_2, work_root, p_clone)\n                }\n\n                // Revert if not all public inputs are field elements (i.e. < p)\n                if iszero(valid_inputs) {\n                    mstore(0x00, PUBLIC_INPUT_GE_P_SELECTOR)\n                    revert(0x00, 0x04)\n                }\n\n                mstore(DELTA_NUMERATOR_LOC, numerator_value)\n                mstore(DELTA_DENOMINATOR_LOC, denominator_value)\n            }\n\n            /**\n             * Compute Plookup delta factor [γ(1 + β)]^{n-k}\n             * k = num roots cut out of Z_H = 4\n             */\n            {\n                let delta_base := mulmod(\n                    mload(C_GAMMA_LOC),\n                    addmod(mload(C_BETA_LOC), 1, p),\n                    p\n                )\n                let delta_numerator := delta_base\n                {\n                    let exponent := mload(N_LOC)\n                    let count := 1\n                    for {\n\n                    } lt(count, exponent) {\n                        count := add(count, count)\n                    } {\n                        delta_numerator := mulmod(\n                            delta_numerator,\n                            delta_numerator,\n                            p\n                        )\n                    }\n                }\n                mstore(PLOOKUP_DELTA_NUMERATOR_LOC, delta_numerator)\n\n                let delta_denominator := mulmod(delta_base, delta_base, p)\n                delta_denominator := mulmod(\n                    delta_denominator,\n                    delta_denominator,\n                    p\n                )\n                mstore(PLOOKUP_DELTA_DENOMINATOR_LOC, delta_denominator)\n            }\n            /**\n             * Compute lagrange poly and vanishing poly fractions\n             */\n            {\n                /**\n                 * vanishing_numerator = zeta\n                 * ZETA_POW_N = zeta^n\n                 * vanishing_numerator -= 1\n                 * accumulating_root = omega_inverse\n                 * work_root = p - accumulating_root\n                 * domain_inverse = domain_inverse\n                 * vanishing_denominator = zeta + work_root\n                 * work_root *= accumulating_root\n                 * vanishing_denominator *= (zeta + work_root)\n                 * work_root *= accumulating_root\n                 * vanishing_denominator *= (zeta + work_root)\n                 * vanishing_denominator *= (zeta + (zeta + accumulating_root))\n                 * work_root = omega\n                 * lagrange_numerator = vanishing_numerator * domain_inverse\n                 * l_start_denominator = zeta - 1\n                 * accumulating_root = work_root^2\n                 * l_end_denominator = accumulating_root^2 * work_root * zeta - 1\n                 * Note: l_end_denominator term contains a term \\omega^5 to cut out 5 roots of unity from vanishing poly\n                 */\n\n                let zeta := mload(C_ZETA_LOC)\n\n                // compute zeta^n, where n is a power of 2\n                let vanishing_numerator := zeta\n                {\n                    // pow_small\n                    let exponent := mload(N_LOC)\n                    let count := 1\n                    for {\n\n                    } lt(count, exponent) {\n                        count := add(count, count)\n                    } {\n                        vanishing_numerator := mulmod(\n                            vanishing_numerator,\n                            vanishing_numerator,\n                            p\n                        )\n                    }\n                }\n                mstore(ZETA_POW_N_LOC, vanishing_numerator)\n                vanishing_numerator := addmod(vanishing_numerator, sub(p, 1), p)\n\n                let accumulating_root := mload(OMEGA_INVERSE_LOC)\n                let work_root := sub(p, accumulating_root)\n                let domain_inverse := mload(DOMAIN_INVERSE_LOC)\n\n                let vanishing_denominator := addmod(zeta, work_root, p)\n                work_root := mulmod(work_root, accumulating_root, p)\n                vanishing_denominator := mulmod(\n                    vanishing_denominator,\n                    addmod(zeta, work_root, p),\n                    p\n                )\n                work_root := mulmod(work_root, accumulating_root, p)\n                vanishing_denominator := mulmod(\n                    vanishing_denominator,\n                    addmod(zeta, work_root, p),\n                    p\n                )\n                vanishing_denominator := mulmod(\n                    vanishing_denominator,\n                    addmod(zeta, mulmod(work_root, accumulating_root, p), p),\n                    p\n                )\n\n                work_root := mload(OMEGA_LOC)\n\n                let lagrange_numerator := mulmod(\n                    vanishing_numerator,\n                    domain_inverse,\n                    p\n                )\n                let l_start_denominator := addmod(zeta, sub(p, 1), p)\n\n                accumulating_root := mulmod(work_root, work_root, p)\n\n                let l_end_denominator := addmod(\n                    mulmod(\n                        mulmod(\n                            mulmod(accumulating_root, accumulating_root, p),\n                            work_root,\n                            p\n                        ),\n                        zeta,\n                        p\n                    ),\n                    sub(p, 1),\n                    p\n                )\n\n                /**\n                 * Compute inversions using Montgomery's batch inversion trick\n                 */\n                let accumulator := mload(DELTA_DENOMINATOR_LOC)\n                let t0 := accumulator\n                accumulator := mulmod(accumulator, vanishing_denominator, p)\n                let t1 := accumulator\n                accumulator := mulmod(accumulator, vanishing_numerator, p)\n                let t2 := accumulator\n                accumulator := mulmod(accumulator, l_start_denominator, p)\n                let t3 := accumulator\n                accumulator := mulmod(\n                    accumulator,\n                    mload(PLOOKUP_DELTA_DENOMINATOR_LOC),\n                    p\n                )\n                let t4 := accumulator\n                {\n                    mstore(0, 0x20)\n                    mstore(0x20, 0x20)\n                    mstore(0x40, 0x20)\n                    mstore(0x60, mulmod(accumulator, l_end_denominator, p))\n                    mstore(0x80, sub(p, 2))\n                    mstore(0xa0, p)\n                    if iszero(staticcall(gas(), 0x05, 0x00, 0xc0, 0x00, 0x20)) {\n                        mstore(0x0, MOD_EXP_FAILURE_SELECTOR)\n                        revert(0x00, 0x04)\n                    }\n                    accumulator := mload(0x00)\n                }\n\n                t4 := mulmod(accumulator, t4, p)\n                accumulator := mulmod(accumulator, l_end_denominator, p)\n\n                t3 := mulmod(accumulator, t3, p)\n                accumulator := mulmod(\n                    accumulator,\n                    mload(PLOOKUP_DELTA_DENOMINATOR_LOC),\n                    p\n                )\n\n                t2 := mulmod(accumulator, t2, p)\n                accumulator := mulmod(accumulator, l_start_denominator, p)\n\n                t1 := mulmod(accumulator, t1, p)\n                accumulator := mulmod(accumulator, vanishing_numerator, p)\n\n                t0 := mulmod(accumulator, t0, p)\n                accumulator := mulmod(accumulator, vanishing_denominator, p)\n\n                accumulator := mulmod(\n                    mulmod(accumulator, accumulator, p),\n                    mload(DELTA_DENOMINATOR_LOC),\n                    p\n                )\n\n                mstore(\n                    PUBLIC_INPUT_DELTA_LOC,\n                    mulmod(mload(DELTA_NUMERATOR_LOC), accumulator, p)\n                )\n                mstore(ZERO_POLY_LOC, mulmod(vanishing_numerator, t0, p))\n                mstore(\n                    ZERO_POLY_INVERSE_LOC,\n                    mulmod(vanishing_denominator, t1, p)\n                )\n                mstore(L_START_LOC, mulmod(lagrange_numerator, t2, p))\n                mstore(\n                    PLOOKUP_DELTA_LOC,\n                    mulmod(mload(PLOOKUP_DELTA_NUMERATOR_LOC), t3, p)\n                )\n                mstore(L_END_LOC, mulmod(lagrange_numerator, t4, p))\n            }\n\n            /**\n             * UltraPlonk Widget Ordering:\n             *\n             * 1. Permutation widget\n             * 2. Plookup widget\n             * 3. Arithmetic widget\n             * 4. Fixed base widget (?)\n             * 5. GenPermSort widget\n             * 6. Elliptic widget\n             * 7. Auxiliary widget\n             */\n\n            /**\n             * COMPUTE PERMUTATION WIDGET EVALUATION\n             */\n            {\n                let alpha := mload(C_ALPHA_LOC)\n                let beta := mload(C_BETA_LOC)\n                let gamma := mload(C_GAMMA_LOC)\n\n                /**\n                 * t1 = (W1 + gamma + beta * ID1) * (W2 + gamma + beta * ID2)\n                 * t2 = (W3 + gamma + beta * ID3) * (W4 + gamma + beta * ID4)\n                 * result = alpha_base * z_eval * t1 * t2\n                 * t1 = (W1 + gamma + beta * sigma_1_eval) * (W2 + gamma + beta * sigma_2_eval)\n                 * t2 = (W2 + gamma + beta * sigma_3_eval) * (W3 + gamma + beta * sigma_4_eval)\n                 * result -= (alpha_base * z_omega_eval * t1 * t2)\n                 */\n                let t1 := mulmod(\n                    add(\n                        add(mload(W1_EVAL_LOC), gamma),\n                        mulmod(beta, mload(ID1_EVAL_LOC), p)\n                    ),\n                    add(\n                        add(mload(W2_EVAL_LOC), gamma),\n                        mulmod(beta, mload(ID2_EVAL_LOC), p)\n                    ),\n                    p\n                )\n                let t2 := mulmod(\n                    add(\n                        add(mload(W3_EVAL_LOC), gamma),\n                        mulmod(beta, mload(ID3_EVAL_LOC), p)\n                    ),\n                    add(\n                        add(mload(W4_EVAL_LOC), gamma),\n                        mulmod(beta, mload(ID4_EVAL_LOC), p)\n                    ),\n                    p\n                )\n                let result := mulmod(\n                    mload(C_ALPHA_BASE_LOC),\n                    mulmod(mload(Z_EVAL_LOC), mulmod(t1, t2, p), p),\n                    p\n                )\n                t1 := mulmod(\n                    add(\n                        add(mload(W1_EVAL_LOC), gamma),\n                        mulmod(beta, mload(SIGMA1_EVAL_LOC), p)\n                    ),\n                    add(\n                        add(mload(W2_EVAL_LOC), gamma),\n                        mulmod(beta, mload(SIGMA2_EVAL_LOC), p)\n                    ),\n                    p\n                )\n                t2 := mulmod(\n                    add(\n                        add(mload(W3_EVAL_LOC), gamma),\n                        mulmod(beta, mload(SIGMA3_EVAL_LOC), p)\n                    ),\n                    add(\n                        add(mload(W4_EVAL_LOC), gamma),\n                        mulmod(beta, mload(SIGMA4_EVAL_LOC), p)\n                    ),\n                    p\n                )\n                result := addmod(\n                    result,\n                    sub(\n                        p,\n                        mulmod(\n                            mload(C_ALPHA_BASE_LOC),\n                            mulmod(\n                                mload(Z_OMEGA_EVAL_LOC),\n                                mulmod(t1, t2, p),\n                                p\n                            ),\n                            p\n                        )\n                    ),\n                    p\n                )\n\n                /**\n                 * alpha_base *= alpha\n                 * result += alpha_base . (L_{n-k}(ʓ) . (z(ʓ.ω) - ∆_{PI}))\n                 * alpha_base *= alpha\n                 * result += alpha_base . (L_1(ʓ)(Z(ʓ) - 1))\n                 * alpha_Base *= alpha\n                 */\n                mstore(\n                    C_ALPHA_BASE_LOC,\n                    mulmod(mload(C_ALPHA_BASE_LOC), mload(C_ALPHA_LOC), p)\n                )\n                result := addmod(\n                    result,\n                    mulmod(\n                        mload(C_ALPHA_BASE_LOC),\n                        mulmod(\n                            mload(L_END_LOC),\n                            addmod(\n                                mload(Z_OMEGA_EVAL_LOC),\n                                sub(p, mload(PUBLIC_INPUT_DELTA_LOC)),\n                                p\n                            ),\n                            p\n                        ),\n                        p\n                    ),\n                    p\n                )\n                mstore(\n                    C_ALPHA_BASE_LOC,\n                    mulmod(mload(C_ALPHA_BASE_LOC), mload(C_ALPHA_LOC), p)\n                )\n                mstore(\n                    PERMUTATION_IDENTITY,\n                    addmod(\n                        result,\n                        mulmod(\n                            mload(C_ALPHA_BASE_LOC),\n                            mulmod(\n                                mload(L_START_LOC),\n                                addmod(mload(Z_EVAL_LOC), sub(p, 1), p),\n                                p\n                            ),\n                            p\n                        ),\n                        p\n                    )\n                )\n                mstore(\n                    C_ALPHA_BASE_LOC,\n                    mulmod(mload(C_ALPHA_BASE_LOC), mload(C_ALPHA_LOC), p)\n                )\n            }\n\n            /**\n             * COMPUTE PLOOKUP WIDGET EVALUATION\n             */\n            {\n                /**\n                 * Goal: f = (w1(z) + q2.w1(zω)) + η(w2(z) + qm.w2(zω)) + η²(w3(z) + qc.w_3(zω)) + q3(z).η³\n                 * f = η.q3(z)\n                 * f += (w3(z) + qc.w_3(zω))\n                 * f *= η\n                 * f += (w2(z) + qm.w2(zω))\n                 * f *= η\n                 * f += (w1(z) + q2.w1(zω))\n                 */\n                let f := mulmod(mload(C_ETA_LOC), mload(Q3_EVAL_LOC), p)\n                f := addmod(\n                    f,\n                    addmod(\n                        mload(W3_EVAL_LOC),\n                        mulmod(mload(QC_EVAL_LOC), mload(W3_OMEGA_EVAL_LOC), p),\n                        p\n                    ),\n                    p\n                )\n                f := mulmod(f, mload(C_ETA_LOC), p)\n                f := addmod(\n                    f,\n                    addmod(\n                        mload(W2_EVAL_LOC),\n                        mulmod(mload(QM_EVAL_LOC), mload(W2_OMEGA_EVAL_LOC), p),\n                        p\n                    ),\n                    p\n                )\n                f := mulmod(f, mload(C_ETA_LOC), p)\n                f := addmod(\n                    f,\n                    addmod(\n                        mload(W1_EVAL_LOC),\n                        mulmod(mload(Q2_EVAL_LOC), mload(W1_OMEGA_EVAL_LOC), p),\n                        p\n                    ),\n                    p\n                )\n\n                // t(z) = table4(z).η³ + table3(z).η² + table2(z).η + table1(z)\n                let t := addmod(\n                    addmod(\n                        addmod(\n                            mulmod(\n                                mload(TABLE4_EVAL_LOC),\n                                mload(C_ETA_CUBE_LOC),\n                                p\n                            ),\n                            mulmod(\n                                mload(TABLE3_EVAL_LOC),\n                                mload(C_ETA_SQR_LOC),\n                                p\n                            ),\n                            p\n                        ),\n                        mulmod(mload(TABLE2_EVAL_LOC), mload(C_ETA_LOC), p),\n                        p\n                    ),\n                    mload(TABLE1_EVAL_LOC),\n                    p\n                )\n\n                // t(zw) = table4(zw).η³ + table3(zw).η² + table2(zw).η + table1(zw)\n                let t_omega := addmod(\n                    addmod(\n                        addmod(\n                            mulmod(\n                                mload(TABLE4_OMEGA_EVAL_LOC),\n                                mload(C_ETA_CUBE_LOC),\n                                p\n                            ),\n                            mulmod(\n                                mload(TABLE3_OMEGA_EVAL_LOC),\n                                mload(C_ETA_SQR_LOC),\n                                p\n                            ),\n                            p\n                        ),\n                        mulmod(\n                            mload(TABLE2_OMEGA_EVAL_LOC),\n                            mload(C_ETA_LOC),\n                            p\n                        ),\n                        p\n                    ),\n                    mload(TABLE1_OMEGA_EVAL_LOC),\n                    p\n                )\n\n                /**\n                 * Goal: numerator = (TABLE_TYPE_EVAL * f(z) + γ) * (t(z) + βt(zω) + γ(β + 1)) * (β + 1)\n                 * gamma_beta_constant = γ(β + 1)\n                 * numerator = f * TABLE_TYPE_EVAL + gamma\n                 * temp0 = t(z) + t(zω) * β + gamma_beta_constant\n                 * numerator *= temp0\n                 * numerator *= (β + 1)\n                 * temp0 = alpha * l_1\n                 * numerator += temp0\n                 * numerator *= z_lookup(z)\n                 * numerator -= temp0\n                 */\n                let gamma_beta_constant := mulmod(\n                    mload(C_GAMMA_LOC),\n                    addmod(mload(C_BETA_LOC), 1, p),\n                    p\n                )\n                let numerator := addmod(\n                    mulmod(f, mload(TABLE_TYPE_EVAL_LOC), p),\n                    mload(C_GAMMA_LOC),\n                    p\n                )\n                let temp0 := addmod(\n                    addmod(t, mulmod(t_omega, mload(C_BETA_LOC), p), p),\n                    gamma_beta_constant,\n                    p\n                )\n                numerator := mulmod(numerator, temp0, p)\n                numerator := mulmod(\n                    numerator,\n                    addmod(mload(C_BETA_LOC), 1, p),\n                    p\n                )\n                temp0 := mulmod(mload(C_ALPHA_LOC), mload(L_START_LOC), p)\n                numerator := addmod(numerator, temp0, p)\n                numerator := mulmod(numerator, mload(Z_LOOKUP_EVAL_LOC), p)\n                numerator := addmod(numerator, sub(p, temp0), p)\n\n                /**\n                 * Goal: denominator = z_lookup(zω)*[s(z) + βs(zω) + γ(1 + β)] - [z_lookup(zω) - [γ(1 + β)]^{n-k}]*α²L_end(z)\n                 * note: delta_factor = [γ(1 + β)]^{n-k}\n                 * denominator = s(z) + βs(zω) + γ(β + 1)\n                 * temp1 = α²L_end(z)\n                 * denominator -= temp1\n                 * denominator *= z_lookup(zω)\n                 * denominator += temp1 * delta_factor\n                 * PLOOKUP_IDENTITY = (numerator - denominator).alpha_base\n                 * alpha_base *= alpha^3\n                 */\n                let denominator := addmod(\n                    addmod(\n                        mload(S_EVAL_LOC),\n                        mulmod(mload(S_OMEGA_EVAL_LOC), mload(C_BETA_LOC), p),\n                        p\n                    ),\n                    gamma_beta_constant,\n                    p\n                )\n                let temp1 := mulmod(mload(C_ALPHA_SQR_LOC), mload(L_END_LOC), p)\n                denominator := addmod(denominator, sub(p, temp1), p)\n                denominator := mulmod(\n                    denominator,\n                    mload(Z_LOOKUP_OMEGA_EVAL_LOC),\n                    p\n                )\n                denominator := addmod(\n                    denominator,\n                    mulmod(temp1, mload(PLOOKUP_DELTA_LOC), p),\n                    p\n                )\n\n                mstore(\n                    PLOOKUP_IDENTITY,\n                    mulmod(\n                        addmod(numerator, sub(p, denominator), p),\n                        mload(C_ALPHA_BASE_LOC),\n                        p\n                    )\n                )\n\n                // update alpha\n                mstore(\n                    C_ALPHA_BASE_LOC,\n                    mulmod(mload(C_ALPHA_BASE_LOC), mload(C_ALPHA_CUBE_LOC), p)\n                )\n            }\n\n            /**\n             * COMPUTE ARITHMETIC WIDGET EVALUATION\n             */\n            {\n                /**\n                 * The basic arithmetic gate identity in standard plonk is as follows.\n                 * (w_1 . w_2 . q_m) + (w_1 . q_1) + (w_2 . q_2) + (w_3 . q_3) + (w_4 . q_4) + q_c = 0\n                 * However, for Ultraplonk, we extend this to support \"passing\" wires between rows (shown without alpha scaling below):\n                 * q_arith * ( ( (-1/2) * (q_arith - 3) * q_m * w_1 * w_2 + q_1 * w_1 + q_2 * w_2 + q_3 * w_3 + q_4 * w_4 + q_c ) +\n                 * (q_arith - 1)*( α * (q_arith - 2) * (w_1 + w_4 - w_1_omega + q_m) + w_4_omega) ) = 0\n                 *\n                 * This formula results in several cases depending on q_arith:\n                 * 1. q_arith == 0: Arithmetic gate is completely disabled\n                 *\n                 * 2. q_arith == 1: Everything in the minigate on the right is disabled. The equation is just a standard plonk equation\n                 * with extra wires: q_m * w_1 * w_2 + q_1 * w_1 + q_2 * w_2 + q_3 * w_3 + q_4 * w_4 + q_c = 0\n                 *\n                 * 3. q_arith == 2: The (w_1 + w_4 - ...) term is disabled. THe equation is:\n                 * (1/2) * q_m * w_1 * w_2 + q_1 * w_1 + q_2 * w_2 + q_3 * w_3 + q_4 * w_4 + q_c + w_4_omega = 0\n                 * It allows defining w_4 at next index (w_4_omega) in terms of current wire values\n                 *\n                 * 4. q_arith == 3: The product of w_1 and w_2 is disabled, but a mini addition gate is enabled. α allows us to split\n                 * the equation into two:\n                 *\n                 * q_1 * w_1 + q_2 * w_2 + q_3 * w_3 + q_4 * w_4 + q_c + 2 * w_4_omega = 0\n                 * and\n                 * w_1 + w_4 - w_1_omega + q_m = 0  (we are reusing q_m here)\n                 *\n                 * 5. q_arith > 3: The product of w_1 and w_2 is scaled by (q_arith - 3), while the w_4_omega term is scaled by (q_arith - 1).\n                 * The equation can be split into two:\n                 *\n                 * (q_arith - 3)* q_m * w_1 * w_ 2 + q_1 * w_1 + q_2 * w_2 + q_3 * w_3 + q_4 * w_4 + q_c + (q_arith - 1) * w_4_omega = 0\n                 * and\n                 * w_1 + w_4 - w_1_omega + q_m = 0\n                 *\n                 * The problem that q_m is used both in both equations can be dealt with by appropriately changing selector values at\n                 * the next gate. Then we can treat (q_arith - 1) as a simulated q_6 selector and scale q_m to handle (q_arith - 3) at\n                 * product.\n                 */\n\n                let w1q1 := mulmod(mload(W1_EVAL_LOC), mload(Q1_EVAL_LOC), p)\n                let w2q2 := mulmod(mload(W2_EVAL_LOC), mload(Q2_EVAL_LOC), p)\n                let w3q3 := mulmod(mload(W3_EVAL_LOC), mload(Q3_EVAL_LOC), p)\n                let w4q3 := mulmod(mload(W4_EVAL_LOC), mload(Q4_EVAL_LOC), p)\n\n                // @todo - Add a explicit test that hits QARITH == 3\n                // w1w2qm := (w_1 . w_2 . q_m . (QARITH_EVAL_LOC - 3)) / 2\n                let w1w2qm := mulmod(\n                    mulmod(\n                        mulmod(\n                            mulmod(mload(W1_EVAL_LOC), mload(W2_EVAL_LOC), p),\n                            mload(QM_EVAL_LOC),\n                            p\n                        ),\n                        addmod(mload(QARITH_EVAL_LOC), sub(p, 3), p),\n                        p\n                    ),\n                    NEGATIVE_INVERSE_OF_2_MODULO_P,\n                    p\n                )\n\n                // (w_1 . w_2 . q_m . (q_arith - 3)) / -2) + (w_1 . q_1) + (w_2 . q_2) + (w_3 . q_3) + (w_4 . q_4) + q_c\n                let identity := addmod(\n                    mload(QC_EVAL_LOC),\n                    addmod(\n                        w4q3,\n                        addmod(\n                            w3q3,\n                            addmod(w2q2, addmod(w1q1, w1w2qm, p), p),\n                            p\n                        ),\n                        p\n                    ),\n                    p\n                )\n\n                // if q_arith == 3 we evaluate an additional mini addition gate (on top of the regular one), where:\n                // w_1 + w_4 - w_1_omega + q_m = 0\n                // we use this gate to save an addition gate when adding or subtracting non-native field elements\n                // α * (q_arith - 2) * (w_1 + w_4 - w_1_omega + q_m)\n                let extra_small_addition_gate_identity := mulmod(\n                    mload(C_ALPHA_LOC),\n                    mulmod(\n                        addmod(mload(QARITH_EVAL_LOC), sub(p, 2), p),\n                        addmod(\n                            mload(QM_EVAL_LOC),\n                            addmod(\n                                sub(p, mload(W1_OMEGA_EVAL_LOC)),\n                                addmod(\n                                    mload(W1_EVAL_LOC),\n                                    mload(W4_EVAL_LOC),\n                                    p\n                                ),\n                                p\n                            ),\n                            p\n                        ),\n                        p\n                    ),\n                    p\n                )\n\n                // if q_arith == 2 OR q_arith == 3 we add the 4th wire of the NEXT gate into the arithmetic identity\n                // N.B. if q_arith > 2, this wire value will be scaled by (q_arith - 1) relative to the other gate wires!\n                // alpha_base * q_arith * (identity + (q_arith - 1) * (w_4_omega + extra_small_addition_gate_identity))\n                mstore(\n                    ARITHMETIC_IDENTITY,\n                    mulmod(\n                        mload(C_ALPHA_BASE_LOC),\n                        mulmod(\n                            mload(QARITH_EVAL_LOC),\n                            addmod(\n                                identity,\n                                mulmod(\n                                    addmod(\n                                        mload(QARITH_EVAL_LOC),\n                                        sub(p, 1),\n                                        p\n                                    ),\n                                    addmod(\n                                        mload(W4_OMEGA_EVAL_LOC),\n                                        extra_small_addition_gate_identity,\n                                        p\n                                    ),\n                                    p\n                                ),\n                                p\n                            ),\n                            p\n                        ),\n                        p\n                    )\n                )\n\n                // update alpha\n                mstore(\n                    C_ALPHA_BASE_LOC,\n                    mulmod(mload(C_ALPHA_BASE_LOC), mload(C_ALPHA_SQR_LOC), p)\n                )\n            }\n\n            /**\n             * COMPUTE GENPERMSORT WIDGET EVALUATION\n             */\n            {\n                /**\n                 * D1 = (w2 - w1)\n                 * D2 = (w3 - w2)\n                 * D3 = (w4 - w3)\n                 * D4 = (w1_omega - w4)\n                 *\n                 * α_a = alpha_base\n                 * α_b = alpha_base * α\n                 * α_c = alpha_base * α^2\n                 * α_d = alpha_base * α^3\n                 *\n                 * range_accumulator = (\n                 *   D1(D1 - 1)(D1 - 2)(D1 - 3).α_a +\n                 *   D2(D2 - 1)(D2 - 2)(D2 - 3).α_b +\n                 *   D3(D3 - 1)(D3 - 2)(D3 - 3).α_c +\n                 *   D4(D4 - 1)(D4 - 2)(D4 - 3).α_d +\n                 * ) . q_sort\n                 */\n                let minus_two := sub(p, 2)\n                let minus_three := sub(p, 3)\n                let d1 := addmod(\n                    mload(W2_EVAL_LOC),\n                    sub(p, mload(W1_EVAL_LOC)),\n                    p\n                )\n                let d2 := addmod(\n                    mload(W3_EVAL_LOC),\n                    sub(p, mload(W2_EVAL_LOC)),\n                    p\n                )\n                let d3 := addmod(\n                    mload(W4_EVAL_LOC),\n                    sub(p, mload(W3_EVAL_LOC)),\n                    p\n                )\n                let d4 := addmod(\n                    mload(W1_OMEGA_EVAL_LOC),\n                    sub(p, mload(W4_EVAL_LOC)),\n                    p\n                )\n\n                let range_accumulator := mulmod(\n                    mulmod(\n                        mulmod(\n                            addmod(mulmod(d1, d1, p), sub(p, d1), p),\n                            addmod(d1, minus_two, p),\n                            p\n                        ),\n                        addmod(d1, minus_three, p),\n                        p\n                    ),\n                    mload(C_ALPHA_BASE_LOC),\n                    p\n                )\n                range_accumulator := addmod(\n                    range_accumulator,\n                    mulmod(\n                        mulmod(\n                            mulmod(\n                                addmod(mulmod(d2, d2, p), sub(p, d2), p),\n                                addmod(d2, minus_two, p),\n                                p\n                            ),\n                            addmod(d2, minus_three, p),\n                            p\n                        ),\n                        mulmod(mload(C_ALPHA_BASE_LOC), mload(C_ALPHA_LOC), p),\n                        p\n                    ),\n                    p\n                )\n                range_accumulator := addmod(\n                    range_accumulator,\n                    mulmod(\n                        mulmod(\n                            mulmod(\n                                addmod(mulmod(d3, d3, p), sub(p, d3), p),\n                                addmod(d3, minus_two, p),\n                                p\n                            ),\n                            addmod(d3, minus_three, p),\n                            p\n                        ),\n                        mulmod(\n                            mload(C_ALPHA_BASE_LOC),\n                            mload(C_ALPHA_SQR_LOC),\n                            p\n                        ),\n                        p\n                    ),\n                    p\n                )\n                range_accumulator := addmod(\n                    range_accumulator,\n                    mulmod(\n                        mulmod(\n                            mulmod(\n                                addmod(mulmod(d4, d4, p), sub(p, d4), p),\n                                addmod(d4, minus_two, p),\n                                p\n                            ),\n                            addmod(d4, minus_three, p),\n                            p\n                        ),\n                        mulmod(\n                            mload(C_ALPHA_BASE_LOC),\n                            mload(C_ALPHA_CUBE_LOC),\n                            p\n                        ),\n                        p\n                    ),\n                    p\n                )\n                range_accumulator := mulmod(\n                    range_accumulator,\n                    mload(QSORT_EVAL_LOC),\n                    p\n                )\n\n                mstore(SORT_IDENTITY, range_accumulator)\n\n                // update alpha\n                mstore(\n                    C_ALPHA_BASE_LOC,\n                    mulmod(mload(C_ALPHA_BASE_LOC), mload(C_ALPHA_QUAD_LOC), p)\n                )\n            }\n\n            /**\n             * COMPUTE ELLIPTIC WIDGET EVALUATION\n             */\n            {\n                /**\n                 * endo_term = (-x_2) * x_1 * (x_3 * 2 + x_1) * q_beta\n                 * endo_sqr_term = x_2^2\n                 * endo_sqr_term *= (x_3 - x_1)\n                 * endo_sqr_term *= q_beta^2\n                 * leftovers = x_2^2\n                 * leftovers *= x_2\n                 * leftovers += x_1^2 * (x_3 + x_1) @follow-up Invalid comment in BB widget\n                 * leftovers -= (y_2^2 + y_1^2)\n                 * sign_term = y_2 * y_1\n                 * sign_term += sign_term\n                 * sign_term *= q_sign\n                 */\n                // q_elliptic * (x3 + x2 + x1)(x2 - x1)(x2 - x1) - y2^2 - y1^2 + 2(y2y1)*q_sign = 0\n                let x_diff := addmod(\n                    mload(X2_EVAL_LOC),\n                    sub(p, mload(X1_EVAL_LOC)),\n                    p\n                )\n                let y2_sqr := mulmod(mload(Y2_EVAL_LOC), mload(Y2_EVAL_LOC), p)\n                let y1_sqr := mulmod(mload(Y1_EVAL_LOC), mload(Y1_EVAL_LOC), p)\n                let y1y2 := mulmod(\n                    mulmod(mload(Y1_EVAL_LOC), mload(Y2_EVAL_LOC), p),\n                    mload(QSIGN_LOC),\n                    p\n                )\n\n                let x_add_identity := addmod(\n                    mulmod(\n                        addmod(\n                            mload(X3_EVAL_LOC),\n                            addmod(mload(X2_EVAL_LOC), mload(X1_EVAL_LOC), p),\n                            p\n                        ),\n                        mulmod(x_diff, x_diff, p),\n                        p\n                    ),\n                    addmod(\n                        sub(p, addmod(y2_sqr, y1_sqr, p)),\n                        addmod(y1y2, y1y2, p),\n                        p\n                    ),\n                    p\n                )\n                x_add_identity := mulmod(\n                    mulmod(\n                        x_add_identity,\n                        addmod(1, sub(p, mload(QM_EVAL_LOC)), p),\n                        p\n                    ),\n                    mload(C_ALPHA_BASE_LOC),\n                    p\n                )\n\n                // q_elliptic * (x3 + x2 + x1)(x2 - x1)(x2 - x1) - y2^2 - y1^2 + 2(y2y1)*q_sign = 0\n                let y1_plus_y3 := addmod(\n                    mload(Y1_EVAL_LOC),\n                    mload(Y3_EVAL_LOC),\n                    p\n                )\n                let y_diff := addmod(\n                    mulmod(mload(Y2_EVAL_LOC), mload(QSIGN_LOC), p),\n                    sub(p, mload(Y1_EVAL_LOC)),\n                    p\n                )\n                let y_add_identity := addmod(\n                    mulmod(y1_plus_y3, x_diff, p),\n                    mulmod(\n                        addmod(\n                            mload(X3_EVAL_LOC),\n                            sub(p, mload(X1_EVAL_LOC)),\n                            p\n                        ),\n                        y_diff,\n                        p\n                    ),\n                    p\n                )\n                y_add_identity := mulmod(\n                    mulmod(\n                        y_add_identity,\n                        addmod(1, sub(p, mload(QM_EVAL_LOC)), p),\n                        p\n                    ),\n                    mulmod(mload(C_ALPHA_BASE_LOC), mload(C_ALPHA_LOC), p),\n                    p\n                )\n\n                // ELLIPTIC_IDENTITY = (x_identity + y_identity) * Q_ELLIPTIC_EVAL\n                mstore(\n                    ELLIPTIC_IDENTITY,\n                    mulmod(\n                        addmod(x_add_identity, y_add_identity, p),\n                        mload(QELLIPTIC_EVAL_LOC),\n                        p\n                    )\n                )\n            }\n            {\n                /**\n                 * x_pow_4 = (y_1_sqr - curve_b) * x_1;\n                 * y_1_sqr_mul_4 = y_1_sqr + y_1_sqr;\n                 * y_1_sqr_mul_4 += y_1_sqr_mul_4;\n                 * x_1_pow_4_mul_9 = x_pow_4;\n                 * x_1_pow_4_mul_9 += x_1_pow_4_mul_9;\n                 * x_1_pow_4_mul_9 += x_1_pow_4_mul_9;\n                 * x_1_pow_4_mul_9 += x_1_pow_4_mul_9;\n                 * x_1_pow_4_mul_9 += x_pow_4;\n                 * x_1_sqr_mul_3 = x_1_sqr + x_1_sqr + x_1_sqr;\n                 * x_double_identity = (x_3 + x_1 + x_1) * y_1_sqr_mul_4 - x_1_pow_4_mul_9;\n                 * y_double_identity = x_1_sqr_mul_3 * (x_1 - x_3) - (y_1 + y_1) * (y_1 + y_3);\n                 */\n                // (x3 + x1 + x1) (4y1*y1) - 9 * x1 * x1 * x1 * x1 = 0\n                let x1_sqr := mulmod(mload(X1_EVAL_LOC), mload(X1_EVAL_LOC), p)\n                let y1_sqr := mulmod(mload(Y1_EVAL_LOC), mload(Y1_EVAL_LOC), p)\n                let x_pow_4 := mulmod(\n                    addmod(y1_sqr, GRUMPKIN_CURVE_B_PARAMETER_NEGATED, p),\n                    mload(X1_EVAL_LOC),\n                    p\n                )\n                let y1_sqr_mul_4 := mulmod(y1_sqr, 4, p)\n                let x1_pow_4_mul_9 := mulmod(x_pow_4, 9, p)\n                let x1_sqr_mul_3 := mulmod(x1_sqr, 3, p)\n                let x_double_identity := addmod(\n                    mulmod(\n                        addmod(\n                            mload(X3_EVAL_LOC),\n                            addmod(mload(X1_EVAL_LOC), mload(X1_EVAL_LOC), p),\n                            p\n                        ),\n                        y1_sqr_mul_4,\n                        p\n                    ),\n                    sub(p, x1_pow_4_mul_9),\n                    p\n                )\n                // (y1 + y1) (2y1) - (3 * x1 * x1)(x1 - x3) = 0\n                let y_double_identity := addmod(\n                    mulmod(\n                        x1_sqr_mul_3,\n                        addmod(\n                            mload(X1_EVAL_LOC),\n                            sub(p, mload(X3_EVAL_LOC)),\n                            p\n                        ),\n                        p\n                    ),\n                    sub(\n                        p,\n                        mulmod(\n                            addmod(mload(Y1_EVAL_LOC), mload(Y1_EVAL_LOC), p),\n                            addmod(mload(Y1_EVAL_LOC), mload(Y3_EVAL_LOC), p),\n                            p\n                        )\n                    ),\n                    p\n                )\n                x_double_identity := mulmod(\n                    x_double_identity,\n                    mload(C_ALPHA_BASE_LOC),\n                    p\n                )\n                y_double_identity := mulmod(\n                    y_double_identity,\n                    mulmod(mload(C_ALPHA_BASE_LOC), mload(C_ALPHA_LOC), p),\n                    p\n                )\n                x_double_identity := mulmod(\n                    x_double_identity,\n                    mload(QM_EVAL_LOC),\n                    p\n                )\n                y_double_identity := mulmod(\n                    y_double_identity,\n                    mload(QM_EVAL_LOC),\n                    p\n                )\n                // ELLIPTIC_IDENTITY += (x_double_identity + y_double_identity) * Q_DOUBLE_EVAL\n                mstore(\n                    ELLIPTIC_IDENTITY,\n                    addmod(\n                        mload(ELLIPTIC_IDENTITY),\n                        mulmod(\n                            addmod(x_double_identity, y_double_identity, p),\n                            mload(QELLIPTIC_EVAL_LOC),\n                            p\n                        ),\n                        p\n                    )\n                )\n\n                // update alpha\n                mstore(\n                    C_ALPHA_BASE_LOC,\n                    mulmod(mload(C_ALPHA_BASE_LOC), mload(C_ALPHA_QUAD_LOC), p)\n                )\n            }\n\n            /**\n             * COMPUTE AUXILIARY WIDGET EVALUATION\n             */\n            {\n                {\n                    /**\n                     * Non native field arithmetic gate 2\n                     *             _                                                                               _\n                     *            /   _                   _                               _       14                \\\n                     * q_2 . q_4 |   (w_1 . w_2) + (w_1 . w_2) + (w_1 . w_4 + w_2 . w_3 - w_3) . 2    - w_3 - w_4   |\n                     *            \\_                                                                               _/\n                     *\n                     * limb_subproduct = w_1 . w_2_omega + w_1_omega . w_2\n                     * non_native_field_gate_2 = w_1 * w_4 + w_4 * w_3 - w_3_omega\n                     * non_native_field_gate_2 = non_native_field_gate_2 * limb_size\n                     * non_native_field_gate_2 -= w_4_omega\n                     * non_native_field_gate_2 += limb_subproduct\n                     * non_native_field_gate_2 *= q_4\n                     * limb_subproduct *= limb_size\n                     * limb_subproduct += w_1_omega * w_2_omega\n                     * non_native_field_gate_1 = (limb_subproduct + w_3 + w_4) * q_3\n                     * non_native_field_gate_3 = (limb_subproduct + w_4 - (w_3_omega + w_4_omega)) * q_m\n                     * non_native_field_identity = (non_native_field_gate_1 + non_native_field_gate_2 + non_native_field_gate_3) * q_2\n                     */\n\n                    let limb_subproduct := addmod(\n                        mulmod(mload(W1_EVAL_LOC), mload(W2_OMEGA_EVAL_LOC), p),\n                        mulmod(mload(W1_OMEGA_EVAL_LOC), mload(W2_EVAL_LOC), p),\n                        p\n                    )\n\n                    let non_native_field_gate_2 := addmod(\n                        addmod(\n                            mulmod(mload(W1_EVAL_LOC), mload(W4_EVAL_LOC), p),\n                            mulmod(mload(W2_EVAL_LOC), mload(W3_EVAL_LOC), p),\n                            p\n                        ),\n                        sub(p, mload(W3_OMEGA_EVAL_LOC)),\n                        p\n                    )\n                    non_native_field_gate_2 := mulmod(\n                        non_native_field_gate_2,\n                        LIMB_SIZE,\n                        p\n                    )\n                    non_native_field_gate_2 := addmod(\n                        non_native_field_gate_2,\n                        sub(p, mload(W4_OMEGA_EVAL_LOC)),\n                        p\n                    )\n                    non_native_field_gate_2 := addmod(\n                        non_native_field_gate_2,\n                        limb_subproduct,\n                        p\n                    )\n                    non_native_field_gate_2 := mulmod(\n                        non_native_field_gate_2,\n                        mload(Q4_EVAL_LOC),\n                        p\n                    )\n                    limb_subproduct := mulmod(limb_subproduct, LIMB_SIZE, p)\n                    limb_subproduct := addmod(\n                        limb_subproduct,\n                        mulmod(\n                            mload(W1_OMEGA_EVAL_LOC),\n                            mload(W2_OMEGA_EVAL_LOC),\n                            p\n                        ),\n                        p\n                    )\n                    let non_native_field_gate_1 := mulmod(\n                        addmod(\n                            limb_subproduct,\n                            sub(\n                                p,\n                                addmod(\n                                    mload(W3_EVAL_LOC),\n                                    mload(W4_EVAL_LOC),\n                                    p\n                                )\n                            ),\n                            p\n                        ),\n                        mload(Q3_EVAL_LOC),\n                        p\n                    )\n                    let non_native_field_gate_3 := mulmod(\n                        addmod(\n                            addmod(limb_subproduct, mload(W4_EVAL_LOC), p),\n                            sub(\n                                p,\n                                addmod(\n                                    mload(W3_OMEGA_EVAL_LOC),\n                                    mload(W4_OMEGA_EVAL_LOC),\n                                    p\n                                )\n                            ),\n                            p\n                        ),\n                        mload(QM_EVAL_LOC),\n                        p\n                    )\n                    let non_native_field_identity := mulmod(\n                        addmod(\n                            addmod(\n                                non_native_field_gate_1,\n                                non_native_field_gate_2,\n                                p\n                            ),\n                            non_native_field_gate_3,\n                            p\n                        ),\n                        mload(Q2_EVAL_LOC),\n                        p\n                    )\n\n                    mstore(\n                        AUX_NON_NATIVE_FIELD_EVALUATION,\n                        non_native_field_identity\n                    )\n                }\n\n                {\n                    /**\n                     * limb_accumulator_1 = w_2_omega;\n                     * limb_accumulator_1 *= SUBLIMB_SHIFT;\n                     * limb_accumulator_1 += w_1_omega;\n                     * limb_accumulator_1 *= SUBLIMB_SHIFT;\n                     * limb_accumulator_1 += w_3;\n                     * limb_accumulator_1 *= SUBLIMB_SHIFT;\n                     * limb_accumulator_1 += w_2;\n                     * limb_accumulator_1 *= SUBLIMB_SHIFT;\n                     * limb_accumulator_1 += w_1;\n                     * limb_accumulator_1 -= w_4;\n                     * limb_accumulator_1 *= q_4;\n                     */\n                    let limb_accumulator_1 := mulmod(\n                        mload(W2_OMEGA_EVAL_LOC),\n                        SUBLIMB_SHIFT,\n                        p\n                    )\n                    limb_accumulator_1 := addmod(\n                        limb_accumulator_1,\n                        mload(W1_OMEGA_EVAL_LOC),\n                        p\n                    )\n                    limb_accumulator_1 := mulmod(\n                        limb_accumulator_1,\n                        SUBLIMB_SHIFT,\n                        p\n                    )\n                    limb_accumulator_1 := addmod(\n                        limb_accumulator_1,\n                        mload(W3_EVAL_LOC),\n                        p\n                    )\n                    limb_accumulator_1 := mulmod(\n                        limb_accumulator_1,\n                        SUBLIMB_SHIFT,\n                        p\n                    )\n                    limb_accumulator_1 := addmod(\n                        limb_accumulator_1,\n                        mload(W2_EVAL_LOC),\n                        p\n                    )\n                    limb_accumulator_1 := mulmod(\n                        limb_accumulator_1,\n                        SUBLIMB_SHIFT,\n                        p\n                    )\n                    limb_accumulator_1 := addmod(\n                        limb_accumulator_1,\n                        mload(W1_EVAL_LOC),\n                        p\n                    )\n                    limb_accumulator_1 := addmod(\n                        limb_accumulator_1,\n                        sub(p, mload(W4_EVAL_LOC)),\n                        p\n                    )\n                    limb_accumulator_1 := mulmod(\n                        limb_accumulator_1,\n                        mload(Q4_EVAL_LOC),\n                        p\n                    )\n\n                    /**\n                     * limb_accumulator_2 = w_3_omega;\n                     * limb_accumulator_2 *= SUBLIMB_SHIFT;\n                     * limb_accumulator_2 += w_2_omega;\n                     * limb_accumulator_2 *= SUBLIMB_SHIFT;\n                     * limb_accumulator_2 += w_1_omega;\n                     * limb_accumulator_2 *= SUBLIMB_SHIFT;\n                     * limb_accumulator_2 += w_4;\n                     * limb_accumulator_2 *= SUBLIMB_SHIFT;\n                     * limb_accumulator_2 += w_3;\n                     * limb_accumulator_2 -= w_4_omega;\n                     * limb_accumulator_2 *= q_m;\n                     */\n                    let limb_accumulator_2 := mulmod(\n                        mload(W3_OMEGA_EVAL_LOC),\n                        SUBLIMB_SHIFT,\n                        p\n                    )\n                    limb_accumulator_2 := addmod(\n                        limb_accumulator_2,\n                        mload(W2_OMEGA_EVAL_LOC),\n                        p\n                    )\n                    limb_accumulator_2 := mulmod(\n                        limb_accumulator_2,\n                        SUBLIMB_SHIFT,\n                        p\n                    )\n                    limb_accumulator_2 := addmod(\n                        limb_accumulator_2,\n                        mload(W1_OMEGA_EVAL_LOC),\n                        p\n                    )\n                    limb_accumulator_2 := mulmod(\n                        limb_accumulator_2,\n                        SUBLIMB_SHIFT,\n                        p\n                    )\n                    limb_accumulator_2 := addmod(\n                        limb_accumulator_2,\n                        mload(W4_EVAL_LOC),\n                        p\n                    )\n                    limb_accumulator_2 := mulmod(\n                        limb_accumulator_2,\n                        SUBLIMB_SHIFT,\n                        p\n                    )\n                    limb_accumulator_2 := addmod(\n                        limb_accumulator_2,\n                        mload(W3_EVAL_LOC),\n                        p\n                    )\n                    limb_accumulator_2 := addmod(\n                        limb_accumulator_2,\n                        sub(p, mload(W4_OMEGA_EVAL_LOC)),\n                        p\n                    )\n                    limb_accumulator_2 := mulmod(\n                        limb_accumulator_2,\n                        mload(QM_EVAL_LOC),\n                        p\n                    )\n\n                    mstore(\n                        AUX_LIMB_ACCUMULATOR_EVALUATION,\n                        mulmod(\n                            addmod(limb_accumulator_1, limb_accumulator_2, p),\n                            mload(Q3_EVAL_LOC),\n                            p\n                        )\n                    )\n                }\n\n                {\n                    /**\n                     * memory_record_check = w_3;\n                     * memory_record_check *= eta;\n                     * memory_record_check += w_2;\n                     * memory_record_check *= eta;\n                     * memory_record_check += w_1;\n                     * memory_record_check *= eta;\n                     * memory_record_check += q_c;\n                     *\n                     * partial_record_check = memory_record_check;\n                     *\n                     * memory_record_check -= w_4;\n                     */\n\n                    let memory_record_check := mulmod(\n                        mload(W3_EVAL_LOC),\n                        mload(C_ETA_LOC),\n                        p\n                    )\n                    memory_record_check := addmod(\n                        memory_record_check,\n                        mload(W2_EVAL_LOC),\n                        p\n                    )\n                    memory_record_check := mulmod(\n                        memory_record_check,\n                        mload(C_ETA_LOC),\n                        p\n                    )\n                    memory_record_check := addmod(\n                        memory_record_check,\n                        mload(W1_EVAL_LOC),\n                        p\n                    )\n                    memory_record_check := mulmod(\n                        memory_record_check,\n                        mload(C_ETA_LOC),\n                        p\n                    )\n                    memory_record_check := addmod(\n                        memory_record_check,\n                        mload(QC_EVAL_LOC),\n                        p\n                    )\n\n                    let partial_record_check := memory_record_check\n                    memory_record_check := addmod(\n                        memory_record_check,\n                        sub(p, mload(W4_EVAL_LOC)),\n                        p\n                    )\n\n                    mstore(AUX_MEMORY_EVALUATION, memory_record_check)\n\n                    // index_delta = w_1_omega - w_1\n                    let index_delta := addmod(\n                        mload(W1_OMEGA_EVAL_LOC),\n                        sub(p, mload(W1_EVAL_LOC)),\n                        p\n                    )\n                    // record_delta = w_4_omega - w_4\n                    let record_delta := addmod(\n                        mload(W4_OMEGA_EVAL_LOC),\n                        sub(p, mload(W4_EVAL_LOC)),\n                        p\n                    )\n                    // index_is_monotonically_increasing = index_delta * (index_delta - 1)\n                    let index_is_monotonically_increasing := mulmod(\n                        index_delta,\n                        addmod(index_delta, sub(p, 1), p),\n                        p\n                    )\n\n                    // adjacent_values_match_if_adjacent_indices_match = record_delta * (1 - index_delta)\n                    let\n                        adjacent_values_match_if_adjacent_indices_match\n                    := mulmod(\n                        record_delta,\n                        addmod(1, sub(p, index_delta), p),\n                        p\n                    )\n\n                    // AUX_ROM_CONSISTENCY_EVALUATION = ((adjacent_values_match_if_adjacent_indices_match * alpha) + index_is_monotonically_increasing) * alpha + partial_record_check\n                    mstore(\n                        AUX_ROM_CONSISTENCY_EVALUATION,\n                        addmod(\n                            mulmod(\n                                addmod(\n                                    mulmod(\n                                        adjacent_values_match_if_adjacent_indices_match,\n                                        mload(C_ALPHA_LOC),\n                                        p\n                                    ),\n                                    index_is_monotonically_increasing,\n                                    p\n                                ),\n                                mload(C_ALPHA_LOC),\n                                p\n                            ),\n                            memory_record_check,\n                            p\n                        )\n                    )\n\n                    {\n                        /**\n                         * next_gate_access_type = w_3_omega;\n                         * next_gate_access_type *= eta;\n                         * next_gate_access_type += w_2_omega;\n                         * next_gate_access_type *= eta;\n                         * next_gate_access_type += w_1_omega;\n                         * next_gate_access_type *= eta;\n                         * next_gate_access_type = w_4_omega - next_gate_access_type;\n                         */\n                        let next_gate_access_type := mulmod(\n                            mload(W3_OMEGA_EVAL_LOC),\n                            mload(C_ETA_LOC),\n                            p\n                        )\n                        next_gate_access_type := addmod(\n                            next_gate_access_type,\n                            mload(W2_OMEGA_EVAL_LOC),\n                            p\n                        )\n                        next_gate_access_type := mulmod(\n                            next_gate_access_type,\n                            mload(C_ETA_LOC),\n                            p\n                        )\n                        next_gate_access_type := addmod(\n                            next_gate_access_type,\n                            mload(W1_OMEGA_EVAL_LOC),\n                            p\n                        )\n                        next_gate_access_type := mulmod(\n                            next_gate_access_type,\n                            mload(C_ETA_LOC),\n                            p\n                        )\n                        next_gate_access_type := addmod(\n                            mload(W4_OMEGA_EVAL_LOC),\n                            sub(p, next_gate_access_type),\n                            p\n                        )\n\n                        // value_delta = w_3_omega - w_3\n                        let value_delta := addmod(\n                            mload(W3_OMEGA_EVAL_LOC),\n                            sub(p, mload(W3_EVAL_LOC)),\n                            p\n                        )\n                        //  adjacent_values_match_if_adjacent_indices_match_and_next_access_is_a_read_operation = (1 - index_delta) * value_delta * (1 - next_gate_access_type);\n\n                        let\n                            adjacent_values_match_if_adjacent_indices_match_and_next_access_is_a_read_operation\n                        := mulmod(\n                            addmod(1, sub(p, index_delta), p),\n                            mulmod(\n                                value_delta,\n                                addmod(1, sub(p, next_gate_access_type), p),\n                                p\n                            ),\n                            p\n                        )\n\n                        // AUX_RAM_CONSISTENCY_EVALUATION\n\n                        /**\n                         * access_type = w_4 - partial_record_check\n                         * access_check = access_type^2 - access_type\n                         * next_gate_access_type_is_boolean = next_gate_access_type^2 - next_gate_access_type\n                         * RAM_consistency_check_identity = adjacent_values_match_if_adjacent_indices_match_and_next_access_is_a_read_operation;\n                         * RAM_consistency_check_identity *= alpha;\n                         * RAM_consistency_check_identity += index_is_monotonically_increasing;\n                         * RAM_consistency_check_identity *= alpha;\n                         * RAM_consistency_check_identity += next_gate_access_type_is_boolean;\n                         * RAM_consistency_check_identity *= alpha;\n                         * RAM_consistency_check_identity += access_check;\n                         */\n\n                        let access_type := addmod(\n                            mload(W4_EVAL_LOC),\n                            sub(p, partial_record_check),\n                            p\n                        )\n                        let access_check := mulmod(\n                            access_type,\n                            addmod(access_type, sub(p, 1), p),\n                            p\n                        )\n                        let next_gate_access_type_is_boolean := mulmod(\n                            next_gate_access_type,\n                            addmod(next_gate_access_type, sub(p, 1), p),\n                            p\n                        )\n                        let RAM_cci := mulmod(\n                            adjacent_values_match_if_adjacent_indices_match_and_next_access_is_a_read_operation,\n                            mload(C_ALPHA_LOC),\n                            p\n                        )\n                        RAM_cci := addmod(\n                            RAM_cci,\n                            index_is_monotonically_increasing,\n                            p\n                        )\n                        RAM_cci := mulmod(RAM_cci, mload(C_ALPHA_LOC), p)\n                        RAM_cci := addmod(\n                            RAM_cci,\n                            next_gate_access_type_is_boolean,\n                            p\n                        )\n                        RAM_cci := mulmod(RAM_cci, mload(C_ALPHA_LOC), p)\n                        RAM_cci := addmod(RAM_cci, access_check, p)\n\n                        mstore(AUX_RAM_CONSISTENCY_EVALUATION, RAM_cci)\n                    }\n\n                    {\n                        // timestamp_delta = w_2_omega - w_2\n                        let timestamp_delta := addmod(\n                            mload(W2_OMEGA_EVAL_LOC),\n                            sub(p, mload(W2_EVAL_LOC)),\n                            p\n                        )\n\n                        // RAM_timestamp_check_identity = (1 - index_delta) * timestamp_delta - w_3\n                        let RAM_timestamp_check_identity := addmod(\n                            mulmod(\n                                timestamp_delta,\n                                addmod(1, sub(p, index_delta), p),\n                                p\n                            ),\n                            sub(p, mload(W3_EVAL_LOC)),\n                            p\n                        )\n\n                        /**\n                         * memory_identity = ROM_consistency_check_identity * q_2;\n                         * memory_identity += RAM_timestamp_check_identity * q_4;\n                         * memory_identity += memory_record_check * q_m;\n                         * memory_identity *= q_1;\n                         * memory_identity += (RAM_consistency_check_identity * q_arith);\n                         *\n                         * auxiliary_identity = memory_identity + non_native_field_identity + limb_accumulator_identity;\n                         * auxiliary_identity *= q_aux;\n                         * auxiliary_identity *= alpha_base;\n                         */\n                        let memory_identity := mulmod(\n                            mload(AUX_ROM_CONSISTENCY_EVALUATION),\n                            mload(Q2_EVAL_LOC),\n                            p\n                        )\n                        memory_identity := addmod(\n                            memory_identity,\n                            mulmod(\n                                RAM_timestamp_check_identity,\n                                mload(Q4_EVAL_LOC),\n                                p\n                            ),\n                            p\n                        )\n                        memory_identity := addmod(\n                            memory_identity,\n                            mulmod(\n                                mload(AUX_MEMORY_EVALUATION),\n                                mload(QM_EVAL_LOC),\n                                p\n                            ),\n                            p\n                        )\n                        memory_identity := mulmod(\n                            memory_identity,\n                            mload(Q1_EVAL_LOC),\n                            p\n                        )\n                        memory_identity := addmod(\n                            memory_identity,\n                            mulmod(\n                                mload(AUX_RAM_CONSISTENCY_EVALUATION),\n                                mload(QARITH_EVAL_LOC),\n                                p\n                            ),\n                            p\n                        )\n\n                        let auxiliary_identity := addmod(\n                            memory_identity,\n                            mload(AUX_NON_NATIVE_FIELD_EVALUATION),\n                            p\n                        )\n                        auxiliary_identity := addmod(\n                            auxiliary_identity,\n                            mload(AUX_LIMB_ACCUMULATOR_EVALUATION),\n                            p\n                        )\n                        auxiliary_identity := mulmod(\n                            auxiliary_identity,\n                            mload(QAUX_EVAL_LOC),\n                            p\n                        )\n                        auxiliary_identity := mulmod(\n                            auxiliary_identity,\n                            mload(C_ALPHA_BASE_LOC),\n                            p\n                        )\n\n                        mstore(AUX_IDENTITY, auxiliary_identity)\n\n                        // update alpha\n                        mstore(\n                            C_ALPHA_BASE_LOC,\n                            mulmod(\n                                mload(C_ALPHA_BASE_LOC),\n                                mload(C_ALPHA_CUBE_LOC),\n                                p\n                            )\n                        )\n                    }\n                }\n            }\n\n            {\n                /**\n                 * quotient = ARITHMETIC_IDENTITY\n                 * quotient += PERMUTATION_IDENTITY\n                 * quotient += PLOOKUP_IDENTITY\n                 * quotient += SORT_IDENTITY\n                 * quotient += ELLIPTIC_IDENTITY\n                 * quotient += AUX_IDENTITY\n                 * quotient *= ZERO_POLY_INVERSE\n                 */\n                mstore(\n                    QUOTIENT_EVAL_LOC,\n                    mulmod(\n                        addmod(\n                            addmod(\n                                addmod(\n                                    addmod(\n                                        addmod(\n                                            mload(PERMUTATION_IDENTITY),\n                                            mload(PLOOKUP_IDENTITY),\n                                            p\n                                        ),\n                                        mload(ARITHMETIC_IDENTITY),\n                                        p\n                                    ),\n                                    mload(SORT_IDENTITY),\n                                    p\n                                ),\n                                mload(ELLIPTIC_IDENTITY),\n                                p\n                            ),\n                            mload(AUX_IDENTITY),\n                            p\n                        ),\n                        mload(ZERO_POLY_INVERSE_LOC),\n                        p\n                    )\n                )\n            }\n\n            /**\n             * GENERATE NU AND SEPARATOR CHALLENGES\n             */\n            {\n                let current_challenge := mload(C_CURRENT_LOC)\n                // get a calldata pointer that points to the start of the data we want to copy\n                let calldata_ptr := add(calldataload(0x04), 0x24)\n\n                calldata_ptr := add(calldata_ptr, NU_CALLDATA_SKIP_LENGTH)\n\n                mstore(NU_CHALLENGE_INPUT_LOC_A, current_challenge)\n                mstore(NU_CHALLENGE_INPUT_LOC_B, mload(QUOTIENT_EVAL_LOC))\n                calldatacopy(\n                    NU_CHALLENGE_INPUT_LOC_C,\n                    calldata_ptr,\n                    NU_INPUT_LENGTH\n                )\n\n                // hash length = (0x20 + num field elements), we include the previous challenge in the hash\n                let challenge := keccak256(\n                    NU_CHALLENGE_INPUT_LOC_A,\n                    add(NU_INPUT_LENGTH, 0x40)\n                )\n\n                mstore(C_V0_LOC, mod(challenge, p))\n                // We need THIRTY-ONE independent nu challenges!\n                mstore(0x00, challenge)\n                mstore8(0x20, 0x01)\n                mstore(C_V1_LOC, mod(keccak256(0x00, 0x21), p))\n                mstore8(0x20, 0x02)\n                mstore(C_V2_LOC, mod(keccak256(0x00, 0x21), p))\n                mstore8(0x20, 0x03)\n                mstore(C_V3_LOC, mod(keccak256(0x00, 0x21), p))\n                mstore8(0x20, 0x04)\n                mstore(C_V4_LOC, mod(keccak256(0x00, 0x21), p))\n                mstore8(0x20, 0x05)\n                mstore(C_V5_LOC, mod(keccak256(0x00, 0x21), p))\n                mstore8(0x20, 0x06)\n                mstore(C_V6_LOC, mod(keccak256(0x00, 0x21), p))\n                mstore8(0x20, 0x07)\n                mstore(C_V7_LOC, mod(keccak256(0x00, 0x21), p))\n                mstore8(0x20, 0x08)\n                mstore(C_V8_LOC, mod(keccak256(0x00, 0x21), p))\n                mstore8(0x20, 0x09)\n                mstore(C_V9_LOC, mod(keccak256(0x00, 0x21), p))\n                mstore8(0x20, 0x0a)\n                mstore(C_V10_LOC, mod(keccak256(0x00, 0x21), p))\n                mstore8(0x20, 0x0b)\n                mstore(C_V11_LOC, mod(keccak256(0x00, 0x21), p))\n                mstore8(0x20, 0x0c)\n                mstore(C_V12_LOC, mod(keccak256(0x00, 0x21), p))\n                mstore8(0x20, 0x0d)\n                mstore(C_V13_LOC, mod(keccak256(0x00, 0x21), p))\n                mstore8(0x20, 0x0e)\n                mstore(C_V14_LOC, mod(keccak256(0x00, 0x21), p))\n                mstore8(0x20, 0x0f)\n                mstore(C_V15_LOC, mod(keccak256(0x00, 0x21), p))\n                mstore8(0x20, 0x10)\n                mstore(C_V16_LOC, mod(keccak256(0x00, 0x21), p))\n                mstore8(0x20, 0x11)\n                mstore(C_V17_LOC, mod(keccak256(0x00, 0x21), p))\n                mstore8(0x20, 0x12)\n                mstore(C_V18_LOC, mod(keccak256(0x00, 0x21), p))\n                mstore8(0x20, 0x13)\n                mstore(C_V19_LOC, mod(keccak256(0x00, 0x21), p))\n                mstore8(0x20, 0x14)\n                mstore(C_V20_LOC, mod(keccak256(0x00, 0x21), p))\n                mstore8(0x20, 0x15)\n                mstore(C_V21_LOC, mod(keccak256(0x00, 0x21), p))\n                mstore8(0x20, 0x16)\n                mstore(C_V22_LOC, mod(keccak256(0x00, 0x21), p))\n                mstore8(0x20, 0x17)\n                mstore(C_V23_LOC, mod(keccak256(0x00, 0x21), p))\n                mstore8(0x20, 0x18)\n                mstore(C_V24_LOC, mod(keccak256(0x00, 0x21), p))\n                mstore8(0x20, 0x19)\n                mstore(C_V25_LOC, mod(keccak256(0x00, 0x21), p))\n                mstore8(0x20, 0x1a)\n                mstore(C_V26_LOC, mod(keccak256(0x00, 0x21), p))\n                mstore8(0x20, 0x1b)\n                mstore(C_V27_LOC, mod(keccak256(0x00, 0x21), p))\n                mstore8(0x20, 0x1c)\n                mstore(C_V28_LOC, mod(keccak256(0x00, 0x21), p))\n                mstore8(0x20, 0x1d)\n                mstore(C_V29_LOC, mod(keccak256(0x00, 0x21), p))\n\n                // @follow-up - Why are both v29 and v30 using appending 0x1d to the prior challenge and hashing, should it not change?\n                mstore8(0x20, 0x1d)\n                challenge := keccak256(0x00, 0x21)\n                mstore(C_V30_LOC, mod(challenge, p))\n\n                // separator\n                mstore(0x00, challenge)\n                mstore(0x20, mload(PI_Z_Y_LOC))\n                mstore(0x40, mload(PI_Z_X_LOC))\n                mstore(0x60, mload(PI_Z_OMEGA_Y_LOC))\n                mstore(0x80, mload(PI_Z_OMEGA_X_LOC))\n\n                mstore(C_U_LOC, mod(keccak256(0x00, 0xa0), p))\n            }\n\n            let success := 0\n            // VALIDATE T1\n            {\n                let x := mload(T1_X_LOC)\n                let y := mload(T1_Y_LOC)\n                let xx := mulmod(x, x, q)\n                // validate on curve\n                success := eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q))\n                mstore(ACCUMULATOR_X_LOC, x)\n                mstore(add(ACCUMULATOR_X_LOC, 0x20), y)\n            }\n            // VALIDATE T2\n            {\n                let x := mload(T2_X_LOC) // 0x1400\n                let y := mload(T2_Y_LOC) // 0x1420\n                let xx := mulmod(x, x, q)\n                // validate on curve\n                success := and(\n                    success,\n                    eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q))\n                )\n                mstore(0x00, x)\n                mstore(0x20, y)\n            }\n            mstore(0x40, mload(ZETA_POW_N_LOC))\n            // accumulator_2 = [T2].zeta^n\n            success := and(\n                success,\n                staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40)\n            )\n            // accumulator = [T1] + accumulator_2\n            success := and(\n                success,\n                staticcall(\n                    gas(),\n                    6,\n                    ACCUMULATOR_X_LOC,\n                    0x80,\n                    ACCUMULATOR_X_LOC,\n                    0x40\n                )\n            )\n\n            // VALIDATE T3\n            {\n                let x := mload(T3_X_LOC)\n                let y := mload(T3_Y_LOC)\n                let xx := mulmod(x, x, q)\n                // validate on curve\n                success := and(\n                    success,\n                    eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q))\n                )\n                mstore(0x00, x)\n                mstore(0x20, y)\n            }\n            mstore(\n                0x40,\n                mulmod(mload(ZETA_POW_N_LOC), mload(ZETA_POW_N_LOC), p)\n            )\n            // accumulator_2 = [T3].zeta^{2n}\n            success := and(\n                success,\n                staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40)\n            )\n            // accumulator = accumulator + accumulator_2\n            success := and(\n                success,\n                staticcall(\n                    gas(),\n                    6,\n                    ACCUMULATOR_X_LOC,\n                    0x80,\n                    ACCUMULATOR_X_LOC,\n                    0x40\n                )\n            )\n\n            // VALIDATE T4\n            {\n                let x := mload(T4_X_LOC)\n                let y := mload(T4_Y_LOC)\n                let xx := mulmod(x, x, q)\n                // validate on curve\n                success := and(\n                    success,\n                    eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q))\n                )\n                mstore(0x00, x)\n                mstore(0x20, y)\n            }\n            mstore(\n                0x40,\n                mulmod(\n                    mulmod(mload(ZETA_POW_N_LOC), mload(ZETA_POW_N_LOC), p),\n                    mload(ZETA_POW_N_LOC),\n                    p\n                )\n            )\n            // accumulator_2 = [T4].zeta^{3n}\n            success := and(\n                success,\n                staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40)\n            )\n            // accumulator = accumulator + accumulator_2\n            success := and(\n                success,\n                staticcall(\n                    gas(),\n                    6,\n                    ACCUMULATOR_X_LOC,\n                    0x80,\n                    ACCUMULATOR_X_LOC,\n                    0x40\n                )\n            )\n\n            // VALIDATE W1\n            {\n                let x := mload(W1_X_LOC)\n                let y := mload(W1_Y_LOC)\n                let xx := mulmod(x, x, q)\n                // validate on curve\n                success := and(\n                    success,\n                    eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q))\n                )\n                mstore(0x00, x)\n                mstore(0x20, y)\n            }\n            mstore(\n                0x40,\n                mulmod(addmod(mload(C_U_LOC), 0x1, p), mload(C_V0_LOC), p)\n            )\n            // accumulator_2 = v0.(u + 1).[W1]\n            success := and(\n                success,\n                staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40)\n            )\n            // accumulator = accumulator + accumulator_2\n            success := and(\n                success,\n                staticcall(\n                    gas(),\n                    6,\n                    ACCUMULATOR_X_LOC,\n                    0x80,\n                    ACCUMULATOR_X_LOC,\n                    0x40\n                )\n            )\n\n            // VALIDATE W2\n            {\n                let x := mload(W2_X_LOC)\n                let y := mload(W2_Y_LOC)\n                let xx := mulmod(x, x, q)\n                // validate on curve\n                success := and(\n                    success,\n                    eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q))\n                )\n                mstore(0x00, x)\n                mstore(0x20, y)\n            }\n            mstore(\n                0x40,\n                mulmod(addmod(mload(C_U_LOC), 0x1, p), mload(C_V1_LOC), p)\n            )\n            // accumulator_2 = v1.(u + 1).[W2]\n            success := and(\n                success,\n                staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40)\n            )\n            // accumulator = accumulator + accumulator_2\n            success := and(\n                success,\n                staticcall(\n                    gas(),\n                    6,\n                    ACCUMULATOR_X_LOC,\n                    0x80,\n                    ACCUMULATOR_X_LOC,\n                    0x40\n                )\n            )\n\n            // VALIDATE W3\n            {\n                let x := mload(W3_X_LOC)\n                let y := mload(W3_Y_LOC)\n                let xx := mulmod(x, x, q)\n                // validate on curve\n                success := and(\n                    success,\n                    eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q))\n                )\n                mstore(0x00, x)\n                mstore(0x20, y)\n            }\n            mstore(\n                0x40,\n                mulmod(addmod(mload(C_U_LOC), 0x1, p), mload(C_V2_LOC), p)\n            )\n            // accumulator_2 = v2.(u + 1).[W3]\n            success := and(\n                success,\n                staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40)\n            )\n            // accumulator = accumulator + accumulator_2\n            success := and(\n                success,\n                staticcall(\n                    gas(),\n                    6,\n                    ACCUMULATOR_X_LOC,\n                    0x80,\n                    ACCUMULATOR_X_LOC,\n                    0x40\n                )\n            )\n\n            // VALIDATE W4\n            {\n                let x := mload(W4_X_LOC)\n                let y := mload(W4_Y_LOC)\n                let xx := mulmod(x, x, q)\n                // validate on curve\n                success := and(\n                    success,\n                    eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q))\n                )\n                mstore(0x00, x)\n                mstore(0x20, y)\n            }\n            mstore(\n                0x40,\n                mulmod(addmod(mload(C_U_LOC), 0x1, p), mload(C_V3_LOC), p)\n            )\n            // accumulator_2 = v3.(u + 1).[W4]\n            success := and(\n                success,\n                staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40)\n            )\n            // accumulator = accumulator + accumulator_2\n            success := and(\n                success,\n                staticcall(\n                    gas(),\n                    6,\n                    ACCUMULATOR_X_LOC,\n                    0x80,\n                    ACCUMULATOR_X_LOC,\n                    0x40\n                )\n            )\n\n            // VALIDATE S\n            {\n                let x := mload(S_X_LOC)\n                let y := mload(S_Y_LOC)\n                let xx := mulmod(x, x, q)\n                // validate on curve\n                success := and(\n                    success,\n                    eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q))\n                )\n                mstore(0x00, x)\n                mstore(0x20, y)\n            }\n            mstore(\n                0x40,\n                mulmod(addmod(mload(C_U_LOC), 0x1, p), mload(C_V4_LOC), p)\n            )\n            // accumulator_2 = v4.(u + 1).[S]\n            success := and(\n                success,\n                staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40)\n            )\n            // accumulator = accumulator + accumulator_2\n            success := and(\n                success,\n                staticcall(\n                    gas(),\n                    6,\n                    ACCUMULATOR_X_LOC,\n                    0x80,\n                    ACCUMULATOR_X_LOC,\n                    0x40\n                )\n            )\n\n            // VALIDATE Z\n            {\n                let x := mload(Z_X_LOC)\n                let y := mload(Z_Y_LOC)\n                let xx := mulmod(x, x, q)\n                // validate on curve\n                success := and(\n                    success,\n                    eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q))\n                )\n                mstore(0x00, x)\n                mstore(0x20, y)\n            }\n            mstore(\n                0x40,\n                mulmod(addmod(mload(C_U_LOC), 0x1, p), mload(C_V5_LOC), p)\n            )\n            // accumulator_2 = v5.(u + 1).[Z]\n            success := and(\n                success,\n                staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40)\n            )\n            // accumulator = accumulator + accumulator_2\n            success := and(\n                success,\n                staticcall(\n                    gas(),\n                    6,\n                    ACCUMULATOR_X_LOC,\n                    0x80,\n                    ACCUMULATOR_X_LOC,\n                    0x40\n                )\n            )\n\n            // VALIDATE Z_LOOKUP\n            {\n                let x := mload(Z_LOOKUP_X_LOC)\n                let y := mload(Z_LOOKUP_Y_LOC)\n                let xx := mulmod(x, x, q)\n                // validate on curve\n                success := and(\n                    success,\n                    eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q))\n                )\n                mstore(0x00, x)\n                mstore(0x20, y)\n            }\n            mstore(\n                0x40,\n                mulmod(addmod(mload(C_U_LOC), 0x1, p), mload(C_V6_LOC), p)\n            )\n            // accumulator_2 = v6.(u + 1).[Z_LOOKUP]\n            success := and(\n                success,\n                staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40)\n            )\n            // accumulator = accumulator + accumulator_2\n            success := and(\n                success,\n                staticcall(\n                    gas(),\n                    6,\n                    ACCUMULATOR_X_LOC,\n                    0x80,\n                    ACCUMULATOR_X_LOC,\n                    0x40\n                )\n            )\n\n            // VALIDATE Q1\n            {\n                let x := mload(Q1_X_LOC)\n                let y := mload(Q1_Y_LOC)\n                let xx := mulmod(x, x, q)\n                // validate on curve\n                success := and(\n                    success,\n                    eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q))\n                )\n                mstore(0x00, x)\n                mstore(0x20, y)\n            }\n            mstore(0x40, mload(C_V7_LOC))\n            // accumulator_2 = v7.[Q1]\n            success := and(\n                success,\n                staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40)\n            )\n            // accumulator = accumulator + accumulator_2\n            success := and(\n                success,\n                staticcall(\n                    gas(),\n                    6,\n                    ACCUMULATOR_X_LOC,\n                    0x80,\n                    ACCUMULATOR_X_LOC,\n                    0x40\n                )\n            )\n\n            // VALIDATE Q2\n            {\n                let x := mload(Q2_X_LOC)\n                let y := mload(Q2_Y_LOC)\n                let xx := mulmod(x, x, q)\n                // validate on curve\n                success := and(\n                    success,\n                    eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q))\n                )\n                mstore(0x00, x)\n                mstore(0x20, y)\n            }\n            mstore(0x40, mload(C_V8_LOC))\n            // accumulator_2 = v8.[Q2]\n            success := and(\n                success,\n                staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40)\n            )\n            // accumulator = accumulator + accumulator_2\n            success := and(\n                success,\n                staticcall(\n                    gas(),\n                    6,\n                    ACCUMULATOR_X_LOC,\n                    0x80,\n                    ACCUMULATOR_X_LOC,\n                    0x40\n                )\n            )\n\n            // VALIDATE Q3\n            {\n                let x := mload(Q3_X_LOC)\n                let y := mload(Q3_Y_LOC)\n                let xx := mulmod(x, x, q)\n                // validate on curve\n                success := and(\n                    success,\n                    eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q))\n                )\n                mstore(0x00, x)\n                mstore(0x20, y)\n            }\n            mstore(0x40, mload(C_V9_LOC))\n            // accumulator_2 = v9.[Q3]\n            success := and(\n                success,\n                staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40)\n            )\n            // accumulator = accumulator + accumulator_2\n            success := and(\n                success,\n                staticcall(\n                    gas(),\n                    6,\n                    ACCUMULATOR_X_LOC,\n                    0x80,\n                    ACCUMULATOR_X_LOC,\n                    0x40\n                )\n            )\n\n            // VALIDATE Q4\n            {\n                let x := mload(Q4_X_LOC)\n                let y := mload(Q4_Y_LOC)\n                let xx := mulmod(x, x, q)\n                // validate on curve\n                success := and(\n                    success,\n                    eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q))\n                )\n                mstore(0x00, x)\n                mstore(0x20, y)\n            }\n            mstore(0x40, mload(C_V10_LOC))\n            // accumulator_2 = v10.[Q4]\n            success := and(\n                success,\n                staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40)\n            )\n            // accumulator = accumulator + accumulator_2\n            success := and(\n                success,\n                staticcall(\n                    gas(),\n                    6,\n                    ACCUMULATOR_X_LOC,\n                    0x80,\n                    ACCUMULATOR_X_LOC,\n                    0x40\n                )\n            )\n\n            // VALIDATE QM\n            {\n                let x := mload(QM_X_LOC)\n                let y := mload(QM_Y_LOC)\n                let xx := mulmod(x, x, q)\n                // validate on curve\n                success := and(\n                    success,\n                    eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q))\n                )\n                mstore(0x00, x)\n                mstore(0x20, y)\n            }\n            mstore(0x40, mload(C_V11_LOC))\n            // accumulator_2 = v11.[Q;]\n            success := and(\n                success,\n                staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40)\n            )\n            // accumulator = accumulator + accumulator_2\n            success := and(\n                success,\n                staticcall(\n                    gas(),\n                    6,\n                    ACCUMULATOR_X_LOC,\n                    0x80,\n                    ACCUMULATOR_X_LOC,\n                    0x40\n                )\n            )\n\n            // VALIDATE QC\n            {\n                let x := mload(QC_X_LOC)\n                let y := mload(QC_Y_LOC)\n                let xx := mulmod(x, x, q)\n                // validate on curve\n                success := and(\n                    success,\n                    eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q))\n                )\n                mstore(0x00, x)\n                mstore(0x20, y)\n            }\n            mstore(0x40, mload(C_V12_LOC))\n            // accumulator_2 = v12.[QC]\n            success := and(\n                success,\n                staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40)\n            )\n            // accumulator = accumulator + accumulator_2\n            success := and(\n                success,\n                staticcall(\n                    gas(),\n                    6,\n                    ACCUMULATOR_X_LOC,\n                    0x80,\n                    ACCUMULATOR_X_LOC,\n                    0x40\n                )\n            )\n\n            // VALIDATE QARITH\n            {\n                let x := mload(QARITH_X_LOC)\n                let y := mload(QARITH_Y_LOC)\n                let xx := mulmod(x, x, q)\n                // validate on curve\n                success := and(\n                    success,\n                    eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q))\n                )\n                mstore(0x00, x)\n                mstore(0x20, y)\n            }\n            mstore(0x40, mload(C_V13_LOC))\n            // accumulator_2 = v13.[QARITH]\n            success := and(\n                success,\n                staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40)\n            )\n            // accumulator = accumulator + accumulator_2\n            success := and(\n                success,\n                staticcall(\n                    gas(),\n                    6,\n                    ACCUMULATOR_X_LOC,\n                    0x80,\n                    ACCUMULATOR_X_LOC,\n                    0x40\n                )\n            )\n\n            // VALIDATE QSORT\n            {\n                let x := mload(QSORT_X_LOC)\n                let y := mload(QSORT_Y_LOC)\n                let xx := mulmod(x, x, q)\n                // validate on curve\n                success := and(\n                    success,\n                    eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q))\n                )\n                mstore(0x00, x)\n                mstore(0x20, y)\n            }\n            mstore(0x40, mload(C_V14_LOC))\n            // accumulator_2 = v14.[QSORT]\n            success := and(\n                success,\n                staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40)\n            )\n            // accumulator = accumulator + accumulator_2\n            success := and(\n                success,\n                staticcall(\n                    gas(),\n                    6,\n                    ACCUMULATOR_X_LOC,\n                    0x80,\n                    ACCUMULATOR_X_LOC,\n                    0x40\n                )\n            )\n\n            // VALIDATE QELLIPTIC\n            {\n                let x := mload(QELLIPTIC_X_LOC)\n                let y := mload(QELLIPTIC_Y_LOC)\n                let xx := mulmod(x, x, q)\n                // validate on curve\n                success := and(\n                    success,\n                    eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q))\n                )\n                mstore(0x00, x)\n                mstore(0x20, y)\n            }\n            mstore(0x40, mload(C_V15_LOC))\n            // accumulator_2 = v15.[QELLIPTIC]\n            success := and(\n                success,\n                staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40)\n            )\n            // accumulator = accumulator + accumulator_2\n            success := and(\n                success,\n                staticcall(\n                    gas(),\n                    6,\n                    ACCUMULATOR_X_LOC,\n                    0x80,\n                    ACCUMULATOR_X_LOC,\n                    0x40\n                )\n            )\n\n            // VALIDATE QAUX\n            {\n                let x := mload(QAUX_X_LOC)\n                let y := mload(QAUX_Y_LOC)\n                let xx := mulmod(x, x, q)\n                // validate on curve\n                success := and(\n                    success,\n                    eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q))\n                )\n                mstore(0x00, x)\n                mstore(0x20, y)\n            }\n            mstore(0x40, mload(C_V16_LOC))\n            // accumulator_2 = v15.[Q_AUX]\n            success := and(\n                success,\n                staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40)\n            )\n            // accumulator = accumulator + accumulator_2\n            success := and(\n                success,\n                staticcall(\n                    gas(),\n                    6,\n                    ACCUMULATOR_X_LOC,\n                    0x80,\n                    ACCUMULATOR_X_LOC,\n                    0x40\n                )\n            )\n\n            // VALIDATE SIGMA1\n            {\n                let x := mload(SIGMA1_X_LOC)\n                let y := mload(SIGMA1_Y_LOC)\n                let xx := mulmod(x, x, q)\n                // validate on curve\n                success := and(\n                    success,\n                    eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q))\n                )\n                mstore(0x00, x)\n                mstore(0x20, y)\n            }\n            mstore(0x40, mload(C_V17_LOC))\n            // accumulator_2 = v17.[sigma1]\n            success := and(\n                success,\n                staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40)\n            )\n            // accumulator = accumulator + accumulator_2\n            success := and(\n                success,\n                staticcall(\n                    gas(),\n                    6,\n                    ACCUMULATOR_X_LOC,\n                    0x80,\n                    ACCUMULATOR_X_LOC,\n                    0x40\n                )\n            )\n\n            // VALIDATE SIGMA2\n            {\n                let x := mload(SIGMA2_X_LOC)\n                let y := mload(SIGMA2_Y_LOC)\n                let xx := mulmod(x, x, q)\n                // validate on curve\n                success := and(\n                    success,\n                    eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q))\n                )\n                mstore(0x00, x)\n                mstore(0x20, y)\n            }\n            mstore(0x40, mload(C_V18_LOC))\n            // accumulator_2 = v18.[sigma2]\n            success := and(\n                success,\n                staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40)\n            )\n            // accumulator = accumulator + accumulator_2\n            success := and(\n                success,\n                staticcall(\n                    gas(),\n                    6,\n                    ACCUMULATOR_X_LOC,\n                    0x80,\n                    ACCUMULATOR_X_LOC,\n                    0x40\n                )\n            )\n\n            // VALIDATE SIGMA3\n            {\n                let x := mload(SIGMA3_X_LOC)\n                let y := mload(SIGMA3_Y_LOC)\n                let xx := mulmod(x, x, q)\n                // validate on curve\n                success := and(\n                    success,\n                    eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q))\n                )\n                mstore(0x00, x)\n                mstore(0x20, y)\n            }\n            mstore(0x40, mload(C_V19_LOC))\n            // accumulator_2 = v19.[sigma3]\n            success := and(\n                success,\n                staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40)\n            )\n            // accumulator = accumulator + accumulator_2\n            success := and(\n                success,\n                staticcall(\n                    gas(),\n                    6,\n                    ACCUMULATOR_X_LOC,\n                    0x80,\n                    ACCUMULATOR_X_LOC,\n                    0x40\n                )\n            )\n\n            // VALIDATE SIGMA4\n            {\n                let x := mload(SIGMA4_X_LOC)\n                let y := mload(SIGMA4_Y_LOC)\n                let xx := mulmod(x, x, q)\n                // validate on curve\n                success := and(\n                    success,\n                    eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q))\n                )\n                mstore(0x00, x)\n                mstore(0x20, y)\n            }\n            mstore(0x40, mload(C_V20_LOC))\n            // accumulator_2 = v20.[sigma4]\n            success := and(\n                success,\n                staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40)\n            )\n            // accumulator = accumulator + accumulator_2\n            success := and(\n                success,\n                staticcall(\n                    gas(),\n                    6,\n                    ACCUMULATOR_X_LOC,\n                    0x80,\n                    ACCUMULATOR_X_LOC,\n                    0x40\n                )\n            )\n\n            // VALIDATE TABLE1\n            {\n                let x := mload(TABLE1_X_LOC)\n                let y := mload(TABLE1_Y_LOC)\n                let xx := mulmod(x, x, q)\n                // validate on curve\n                success := and(\n                    success,\n                    eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q))\n                )\n                mstore(0x00, x)\n                mstore(0x20, y)\n            }\n            mstore(\n                0x40,\n                mulmod(addmod(mload(C_U_LOC), 0x1, p), mload(C_V21_LOC), p)\n            )\n            // accumulator_2 = u.[table1]\n            success := and(\n                success,\n                staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40)\n            )\n            // accumulator = accumulator + accumulator_2\n            success := and(\n                success,\n                staticcall(\n                    gas(),\n                    6,\n                    ACCUMULATOR_X_LOC,\n                    0x80,\n                    ACCUMULATOR_X_LOC,\n                    0x40\n                )\n            )\n\n            // VALIDATE TABLE2\n            {\n                let x := mload(TABLE2_X_LOC)\n                let y := mload(TABLE2_Y_LOC)\n                let xx := mulmod(x, x, q)\n                // validate on curve\n                success := and(\n                    success,\n                    eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q))\n                )\n                mstore(0x00, x)\n                mstore(0x20, y)\n            }\n            mstore(\n                0x40,\n                mulmod(addmod(mload(C_U_LOC), 0x1, p), mload(C_V22_LOC), p)\n            )\n            // accumulator_2 = u.[table2]\n            success := and(\n                success,\n                staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40)\n            )\n            // accumulator = accumulator + accumulator_2\n            success := and(\n                success,\n                staticcall(\n                    gas(),\n                    6,\n                    ACCUMULATOR_X_LOC,\n                    0x80,\n                    ACCUMULATOR_X_LOC,\n                    0x40\n                )\n            )\n\n            // VALIDATE TABLE3\n            {\n                let x := mload(TABLE3_X_LOC)\n                let y := mload(TABLE3_Y_LOC)\n                let xx := mulmod(x, x, q)\n                // validate on curve\n                success := and(\n                    success,\n                    eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q))\n                )\n                mstore(0x00, x)\n                mstore(0x20, y)\n            }\n            mstore(\n                0x40,\n                mulmod(addmod(mload(C_U_LOC), 0x1, p), mload(C_V23_LOC), p)\n            )\n            // accumulator_2 = u.[table3]\n            success := and(\n                success,\n                staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40)\n            )\n            // accumulator = accumulator + accumulator_2\n            success := and(\n                success,\n                staticcall(\n                    gas(),\n                    6,\n                    ACCUMULATOR_X_LOC,\n                    0x80,\n                    ACCUMULATOR_X_LOC,\n                    0x40\n                )\n            )\n\n            // VALIDATE TABLE4\n            {\n                let x := mload(TABLE4_X_LOC)\n                let y := mload(TABLE4_Y_LOC)\n                let xx := mulmod(x, x, q)\n                // validate on curve\n                success := and(\n                    success,\n                    eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q))\n                )\n                mstore(0x00, x)\n                mstore(0x20, y)\n            }\n            mstore(\n                0x40,\n                mulmod(addmod(mload(C_U_LOC), 0x1, p), mload(C_V24_LOC), p)\n            )\n            // accumulator_2 = u.[table4]\n            success := and(\n                success,\n                staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40)\n            )\n            // accumulator = accumulator + accumulator_2\n            success := and(\n                success,\n                staticcall(\n                    gas(),\n                    6,\n                    ACCUMULATOR_X_LOC,\n                    0x80,\n                    ACCUMULATOR_X_LOC,\n                    0x40\n                )\n            )\n\n            // VALIDATE TABLE_TYPE\n            {\n                let x := mload(TABLE_TYPE_X_LOC)\n                let y := mload(TABLE_TYPE_Y_LOC)\n                let xx := mulmod(x, x, q)\n                // validate on curve\n                success := and(\n                    success,\n                    eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q))\n                )\n                mstore(0x00, x)\n                mstore(0x20, y)\n            }\n            mstore(0x40, mload(C_V25_LOC))\n            // accumulator_2 = v25.[TableType]\n            success := and(\n                success,\n                staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40)\n            )\n            // accumulator = accumulator + accumulator_2\n            success := and(\n                success,\n                staticcall(\n                    gas(),\n                    6,\n                    ACCUMULATOR_X_LOC,\n                    0x80,\n                    ACCUMULATOR_X_LOC,\n                    0x40\n                )\n            )\n\n            // VALIDATE ID1\n            {\n                let x := mload(ID1_X_LOC)\n                let y := mload(ID1_Y_LOC)\n                let xx := mulmod(x, x, q)\n                // validate on curve\n                success := and(\n                    success,\n                    eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q))\n                )\n                mstore(0x00, x)\n                mstore(0x20, y)\n            }\n            mstore(0x40, mload(C_V26_LOC))\n            // accumulator_2 = v26.[ID1]\n            success := and(\n                success,\n                staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40)\n            )\n            // accumulator = accumulator + accumulator_2\n            success := and(\n                success,\n                staticcall(\n                    gas(),\n                    6,\n                    ACCUMULATOR_X_LOC,\n                    0x80,\n                    ACCUMULATOR_X_LOC,\n                    0x40\n                )\n            )\n\n            // VALIDATE ID2\n            {\n                let x := mload(ID2_X_LOC)\n                let y := mload(ID2_Y_LOC)\n                let xx := mulmod(x, x, q)\n                // validate on curve\n                success := and(\n                    success,\n                    eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q))\n                )\n                mstore(0x00, x)\n                mstore(0x20, y)\n            }\n            mstore(0x40, mload(C_V27_LOC))\n            // accumulator_2 = v27.[ID2]\n            success := and(\n                success,\n                staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40)\n            )\n            // accumulator = accumulator + accumulator_2\n            success := and(\n                success,\n                staticcall(\n                    gas(),\n                    6,\n                    ACCUMULATOR_X_LOC,\n                    0x80,\n                    ACCUMULATOR_X_LOC,\n                    0x40\n                )\n            )\n\n            // VALIDATE ID3\n            {\n                let x := mload(ID3_X_LOC)\n                let y := mload(ID3_Y_LOC)\n                let xx := mulmod(x, x, q)\n                // validate on curve\n                success := and(\n                    success,\n                    eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q))\n                )\n                mstore(0x00, x)\n                mstore(0x20, y)\n            }\n            mstore(0x40, mload(C_V28_LOC))\n            // accumulator_2 = v28.[ID3]\n            success := and(\n                success,\n                staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40)\n            )\n            // accumulator = accumulator + accumulator_2\n            success := and(\n                success,\n                staticcall(\n                    gas(),\n                    6,\n                    ACCUMULATOR_X_LOC,\n                    0x80,\n                    ACCUMULATOR_X_LOC,\n                    0x40\n                )\n            )\n\n            // VALIDATE ID4\n            {\n                let x := mload(ID4_X_LOC)\n                let y := mload(ID4_Y_LOC)\n                let xx := mulmod(x, x, q)\n                // validate on curve\n                success := and(\n                    success,\n                    eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q))\n                )\n                mstore(0x00, x)\n                mstore(0x20, y)\n            }\n            mstore(0x40, mload(C_V29_LOC))\n            // accumulator_2 = v29.[ID4]\n            success := and(\n                success,\n                staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40)\n            )\n            // accumulator = accumulator + accumulator_2\n            success := and(\n                success,\n                staticcall(\n                    gas(),\n                    6,\n                    ACCUMULATOR_X_LOC,\n                    0x80,\n                    ACCUMULATOR_X_LOC,\n                    0x40\n                )\n            )\n\n            /**\n             * COMPUTE BATCH EVALUATION SCALAR MULTIPLIER\n             */\n            {\n                /**\n                 * batch_evaluation = v0 * (w_1_omega * u + w_1_eval)\n                 * batch_evaluation += v1 * (w_2_omega * u + w_2_eval)\n                 * batch_evaluation += v2 * (w_3_omega * u + w_3_eval)\n                 * batch_evaluation += v3 * (w_4_omega * u + w_4_eval)\n                 * batch_evaluation += v4 * (s_omega_eval * u + s_eval)\n                 * batch_evaluation += v5 * (z_omega_eval * u + z_eval)\n                 * batch_evaluation += v6 * (z_lookup_omega_eval * u + z_lookup_eval)\n                 */\n                let batch_evaluation := mulmod(\n                    mload(C_V0_LOC),\n                    addmod(\n                        mulmod(mload(W1_OMEGA_EVAL_LOC), mload(C_U_LOC), p),\n                        mload(W1_EVAL_LOC),\n                        p\n                    ),\n                    p\n                )\n                batch_evaluation := addmod(\n                    batch_evaluation,\n                    mulmod(\n                        mload(C_V1_LOC),\n                        addmod(\n                            mulmod(mload(W2_OMEGA_EVAL_LOC), mload(C_U_LOC), p),\n                            mload(W2_EVAL_LOC),\n                            p\n                        ),\n                        p\n                    ),\n                    p\n                )\n                batch_evaluation := addmod(\n                    batch_evaluation,\n                    mulmod(\n                        mload(C_V2_LOC),\n                        addmod(\n                            mulmod(mload(W3_OMEGA_EVAL_LOC), mload(C_U_LOC), p),\n                            mload(W3_EVAL_LOC),\n                            p\n                        ),\n                        p\n                    ),\n                    p\n                )\n                batch_evaluation := addmod(\n                    batch_evaluation,\n                    mulmod(\n                        mload(C_V3_LOC),\n                        addmod(\n                            mulmod(mload(W4_OMEGA_EVAL_LOC), mload(C_U_LOC), p),\n                            mload(W4_EVAL_LOC),\n                            p\n                        ),\n                        p\n                    ),\n                    p\n                )\n                batch_evaluation := addmod(\n                    batch_evaluation,\n                    mulmod(\n                        mload(C_V4_LOC),\n                        addmod(\n                            mulmod(mload(S_OMEGA_EVAL_LOC), mload(C_U_LOC), p),\n                            mload(S_EVAL_LOC),\n                            p\n                        ),\n                        p\n                    ),\n                    p\n                )\n                batch_evaluation := addmod(\n                    batch_evaluation,\n                    mulmod(\n                        mload(C_V5_LOC),\n                        addmod(\n                            mulmod(mload(Z_OMEGA_EVAL_LOC), mload(C_U_LOC), p),\n                            mload(Z_EVAL_LOC),\n                            p\n                        ),\n                        p\n                    ),\n                    p\n                )\n                batch_evaluation := addmod(\n                    batch_evaluation,\n                    mulmod(\n                        mload(C_V6_LOC),\n                        addmod(\n                            mulmod(\n                                mload(Z_LOOKUP_OMEGA_EVAL_LOC),\n                                mload(C_U_LOC),\n                                p\n                            ),\n                            mload(Z_LOOKUP_EVAL_LOC),\n                            p\n                        ),\n                        p\n                    ),\n                    p\n                )\n\n                /**\n                 * batch_evaluation += v7 * Q1_EVAL\n                 * batch_evaluation += v8 * Q2_EVAL\n                 * batch_evaluation += v9 * Q3_EVAL\n                 * batch_evaluation += v10 * Q4_EVAL\n                 * batch_evaluation += v11 * QM_EVAL\n                 * batch_evaluation += v12 * QC_EVAL\n                 * batch_evaluation += v13 * QARITH_EVAL\n                 * batch_evaluation += v14 * QSORT_EVAL_LOC\n                 * batch_evaluation += v15 * QELLIPTIC_EVAL_LOC\n                 * batch_evaluation += v16 * QAUX_EVAL_LOC\n                 * batch_evaluation += v17 * SIGMA1_EVAL_LOC\n                 * batch_evaluation += v18 * SIGMA2_EVAL_LOC\n                 * batch_evaluation += v19 * SIGMA3_EVAL_LOC\n                 * batch_evaluation += v20 * SIGMA4_EVAL_LOC\n                 */\n                batch_evaluation := addmod(\n                    batch_evaluation,\n                    mulmod(mload(C_V7_LOC), mload(Q1_EVAL_LOC), p),\n                    p\n                )\n                batch_evaluation := addmod(\n                    batch_evaluation,\n                    mulmod(mload(C_V8_LOC), mload(Q2_EVAL_LOC), p),\n                    p\n                )\n                batch_evaluation := addmod(\n                    batch_evaluation,\n                    mulmod(mload(C_V9_LOC), mload(Q3_EVAL_LOC), p),\n                    p\n                )\n                batch_evaluation := addmod(\n                    batch_evaluation,\n                    mulmod(mload(C_V10_LOC), mload(Q4_EVAL_LOC), p),\n                    p\n                )\n                batch_evaluation := addmod(\n                    batch_evaluation,\n                    mulmod(mload(C_V11_LOC), mload(QM_EVAL_LOC), p),\n                    p\n                )\n                batch_evaluation := addmod(\n                    batch_evaluation,\n                    mulmod(mload(C_V12_LOC), mload(QC_EVAL_LOC), p),\n                    p\n                )\n                batch_evaluation := addmod(\n                    batch_evaluation,\n                    mulmod(mload(C_V13_LOC), mload(QARITH_EVAL_LOC), p),\n                    p\n                )\n                batch_evaluation := addmod(\n                    batch_evaluation,\n                    mulmod(mload(C_V14_LOC), mload(QSORT_EVAL_LOC), p),\n                    p\n                )\n                batch_evaluation := addmod(\n                    batch_evaluation,\n                    mulmod(mload(C_V15_LOC), mload(QELLIPTIC_EVAL_LOC), p),\n                    p\n                )\n                batch_evaluation := addmod(\n                    batch_evaluation,\n                    mulmod(mload(C_V16_LOC), mload(QAUX_EVAL_LOC), p),\n                    p\n                )\n                batch_evaluation := addmod(\n                    batch_evaluation,\n                    mulmod(mload(C_V17_LOC), mload(SIGMA1_EVAL_LOC), p),\n                    p\n                )\n                batch_evaluation := addmod(\n                    batch_evaluation,\n                    mulmod(mload(C_V18_LOC), mload(SIGMA2_EVAL_LOC), p),\n                    p\n                )\n                batch_evaluation := addmod(\n                    batch_evaluation,\n                    mulmod(mload(C_V19_LOC), mload(SIGMA3_EVAL_LOC), p),\n                    p\n                )\n                batch_evaluation := addmod(\n                    batch_evaluation,\n                    mulmod(mload(C_V20_LOC), mload(SIGMA4_EVAL_LOC), p),\n                    p\n                )\n\n                /**\n                 * batch_evaluation += v21 * (table1(zw) * u + table1(z))\n                 * batch_evaluation += v22 * (table2(zw) * u + table2(z))\n                 * batch_evaluation += v23 * (table3(zw) * u + table3(z))\n                 * batch_evaluation += v24 * (table4(zw) * u + table4(z))\n                 * batch_evaluation += v25 * table_type_eval\n                 * batch_evaluation += v26 * id1_eval\n                 * batch_evaluation += v27 * id2_eval\n                 * batch_evaluation += v28 * id3_eval\n                 * batch_evaluation += v29 * id4_eval\n                 * batch_evaluation += quotient_eval\n                 */\n                batch_evaluation := addmod(\n                    batch_evaluation,\n                    mulmod(\n                        mload(C_V21_LOC),\n                        addmod(\n                            mulmod(\n                                mload(TABLE1_OMEGA_EVAL_LOC),\n                                mload(C_U_LOC),\n                                p\n                            ),\n                            mload(TABLE1_EVAL_LOC),\n                            p\n                        ),\n                        p\n                    ),\n                    p\n                )\n                batch_evaluation := addmod(\n                    batch_evaluation,\n                    mulmod(\n                        mload(C_V22_LOC),\n                        addmod(\n                            mulmod(\n                                mload(TABLE2_OMEGA_EVAL_LOC),\n                                mload(C_U_LOC),\n                                p\n                            ),\n                            mload(TABLE2_EVAL_LOC),\n                            p\n                        ),\n                        p\n                    ),\n                    p\n                )\n                batch_evaluation := addmod(\n                    batch_evaluation,\n                    mulmod(\n                        mload(C_V23_LOC),\n                        addmod(\n                            mulmod(\n                                mload(TABLE3_OMEGA_EVAL_LOC),\n                                mload(C_U_LOC),\n                                p\n                            ),\n                            mload(TABLE3_EVAL_LOC),\n                            p\n                        ),\n                        p\n                    ),\n                    p\n                )\n                batch_evaluation := addmod(\n                    batch_evaluation,\n                    mulmod(\n                        mload(C_V24_LOC),\n                        addmod(\n                            mulmod(\n                                mload(TABLE4_OMEGA_EVAL_LOC),\n                                mload(C_U_LOC),\n                                p\n                            ),\n                            mload(TABLE4_EVAL_LOC),\n                            p\n                        ),\n                        p\n                    ),\n                    p\n                )\n                batch_evaluation := addmod(\n                    batch_evaluation,\n                    mulmod(mload(C_V25_LOC), mload(TABLE_TYPE_EVAL_LOC), p),\n                    p\n                )\n                batch_evaluation := addmod(\n                    batch_evaluation,\n                    mulmod(mload(C_V26_LOC), mload(ID1_EVAL_LOC), p),\n                    p\n                )\n                batch_evaluation := addmod(\n                    batch_evaluation,\n                    mulmod(mload(C_V27_LOC), mload(ID2_EVAL_LOC), p),\n                    p\n                )\n                batch_evaluation := addmod(\n                    batch_evaluation,\n                    mulmod(mload(C_V28_LOC), mload(ID3_EVAL_LOC), p),\n                    p\n                )\n                batch_evaluation := addmod(\n                    batch_evaluation,\n                    mulmod(mload(C_V29_LOC), mload(ID4_EVAL_LOC), p),\n                    p\n                )\n                batch_evaluation := addmod(\n                    batch_evaluation,\n                    mload(QUOTIENT_EVAL_LOC),\n                    p\n                )\n\n                mstore(0x00, 0x01) // [1].x\n                mstore(0x20, 0x02) // [1].y\n                mstore(0x40, sub(p, batch_evaluation))\n                // accumulator_2 = -[1].(batch_evaluation)\n                success := and(\n                    success,\n                    staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40)\n                )\n                // accumulator = accumulator + accumulator_2\n                success := and(\n                    success,\n                    staticcall(\n                        gas(),\n                        6,\n                        ACCUMULATOR_X_LOC,\n                        0x80,\n                        ACCUMULATOR_X_LOC,\n                        0x40\n                    )\n                )\n\n                mstore(OPENING_COMMITMENT_SUCCESS_FLAG, success)\n            }\n\n            /**\n             * PERFORM PAIRING PREAMBLE\n             */\n            {\n                let u := mload(C_U_LOC)\n                let zeta := mload(C_ZETA_LOC)\n                // VALIDATE PI_Z\n                {\n                    let x := mload(PI_Z_X_LOC)\n                    let y := mload(PI_Z_Y_LOC)\n                    let xx := mulmod(x, x, q)\n                    // validate on curve\n                    success := eq(\n                        mulmod(y, y, q),\n                        addmod(mulmod(x, xx, q), 3, q)\n                    )\n                    mstore(0x00, x)\n                    mstore(0x20, y)\n                }\n                // compute zeta.[PI_Z] and add into accumulator\n                mstore(0x40, zeta)\n                success := and(\n                    success,\n                    staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40)\n                )\n                // accumulator = accumulator + accumulator_2\n                success := and(\n                    success,\n                    staticcall(\n                        gas(),\n                        6,\n                        ACCUMULATOR_X_LOC,\n                        0x80,\n                        ACCUMULATOR_X_LOC,\n                        0x40\n                    )\n                )\n\n                // VALIDATE PI_Z_OMEGA\n                {\n                    let x := mload(PI_Z_OMEGA_X_LOC)\n                    let y := mload(PI_Z_OMEGA_Y_LOC)\n                    let xx := mulmod(x, x, q)\n                    // validate on curve\n                    success := and(\n                        success,\n                        eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q))\n                    )\n                    mstore(0x00, x)\n                    mstore(0x20, y)\n                }\n                mstore(0x40, mulmod(mulmod(u, zeta, p), mload(OMEGA_LOC), p))\n                // accumulator_2 = u.zeta.omega.[PI_Z_OMEGA]\n                success := and(\n                    success,\n                    staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40)\n                )\n                // PAIRING_RHS = accumulator + accumulator_2\n                success := and(\n                    success,\n                    staticcall(\n                        gas(),\n                        6,\n                        ACCUMULATOR_X_LOC,\n                        0x80,\n                        PAIRING_RHS_X_LOC,\n                        0x40\n                    )\n                )\n\n                mstore(0x00, mload(PI_Z_X_LOC))\n                mstore(0x20, mload(PI_Z_Y_LOC))\n                mstore(0x40, mload(PI_Z_OMEGA_X_LOC))\n                mstore(0x60, mload(PI_Z_OMEGA_Y_LOC))\n                mstore(0x80, u)\n                success := and(\n                    success,\n                    staticcall(gas(), 7, 0x40, 0x60, 0x40, 0x40)\n                )\n                // PAIRING_LHS = [PI_Z] + [PI_Z_OMEGA] * u\n                success := and(\n                    success,\n                    staticcall(gas(), 6, 0x00, 0x80, PAIRING_LHS_X_LOC, 0x40)\n                )\n                // negate lhs y-coordinate\n                mstore(PAIRING_LHS_Y_LOC, sub(q, mload(PAIRING_LHS_Y_LOC)))\n\n                if mload(CONTAINS_RECURSIVE_PROOF_LOC) {\n                    // VALIDATE RECURSIVE P1\n                    {\n                        let x := mload(RECURSIVE_P1_X_LOC)\n                        let y := mload(RECURSIVE_P1_Y_LOC)\n                        let xx := mulmod(x, x, q)\n                        // validate on curve\n                        success := and(\n                            success,\n                            eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q))\n                        )\n                        mstore(0x00, x)\n                        mstore(0x20, y)\n                    }\n\n                    // compute u.u.[recursive_p1] and write into 0x60\n                    mstore(0x40, mulmod(u, u, p))\n                    success := and(\n                        success,\n                        staticcall(gas(), 7, 0x00, 0x60, 0x60, 0x40)\n                    )\n                    // VALIDATE RECURSIVE P2\n                    {\n                        let x := mload(RECURSIVE_P2_X_LOC)\n                        let y := mload(RECURSIVE_P2_Y_LOC)\n                        let xx := mulmod(x, x, q)\n                        // validate on curve\n                        success := and(\n                            success,\n                            eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q))\n                        )\n                        mstore(0x00, x)\n                        mstore(0x20, y)\n                    }\n                    // compute u.u.[recursive_p2] and write into 0x00\n                    // 0x40 still contains u*u\n                    success := and(\n                        success,\n                        staticcall(gas(), 7, 0x00, 0x60, 0x00, 0x40)\n                    )\n\n                    // compute u.u.[recursiveP1] + rhs and write into rhs\n                    mstore(0xa0, mload(PAIRING_RHS_X_LOC))\n                    mstore(0xc0, mload(PAIRING_RHS_Y_LOC))\n                    success := and(\n                        success,\n                        staticcall(\n                            gas(),\n                            6,\n                            0x60,\n                            0x80,\n                            PAIRING_RHS_X_LOC,\n                            0x40\n                        )\n                    )\n\n                    // compute u.u.[recursiveP2] + lhs and write into lhs\n                    mstore(0x40, mload(PAIRING_LHS_X_LOC))\n                    mstore(0x60, mload(PAIRING_LHS_Y_LOC))\n                    success := and(\n                        success,\n                        staticcall(\n                            gas(),\n                            6,\n                            0x00,\n                            0x80,\n                            PAIRING_LHS_X_LOC,\n                            0x40\n                        )\n                    )\n                }\n\n                if iszero(success) {\n                    mstore(0x0, EC_SCALAR_MUL_FAILURE_SELECTOR)\n                    revert(0x00, 0x04)\n                }\n                mstore(PAIRING_PREAMBLE_SUCCESS_FLAG, success)\n            }\n\n            /**\n             * PERFORM PAIRING\n             */\n            {\n                // rhs paired with [1]_2\n                // lhs paired with [x]_2\n\n                mstore(0x00, mload(PAIRING_RHS_X_LOC))\n                mstore(0x20, mload(PAIRING_RHS_Y_LOC))\n                mstore(\n                    0x40,\n                    0x198e9393920d483a7260bfb731fb5d25f1aa493335a9e71297e485b7aef312c2\n                ) // this is [1]_2\n                mstore(\n                    0x60,\n                    0x1800deef121f1e76426a00665e5c4479674322d4f75edadd46debd5cd992f6ed\n                )\n                mstore(\n                    0x80,\n                    0x090689d0585ff075ec9e99ad690c3395bc4b313370b38ef355acdadcd122975b\n                )\n                mstore(\n                    0xa0,\n                    0x12c85ea5db8c6deb4aab71808dcb408fe3d1e7690c43d37b4ce6cc0166fa7daa\n                )\n\n                mstore(0xc0, mload(PAIRING_LHS_X_LOC))\n                mstore(0xe0, mload(PAIRING_LHS_Y_LOC))\n                mstore(0x100, mload(G2X_X0_LOC))\n                mstore(0x120, mload(G2X_X1_LOC))\n                mstore(0x140, mload(G2X_Y0_LOC))\n                mstore(0x160, mload(G2X_Y1_LOC))\n\n                success := staticcall(gas(), 8, 0x00, 0x180, 0x00, 0x20)\n                mstore(PAIRING_SUCCESS_FLAG, success)\n                mstore(RESULT_FLAG, mload(0x00))\n            }\n            if iszero(\n                and(\n                    and(\n                        and(mload(PAIRING_SUCCESS_FLAG), mload(RESULT_FLAG)),\n                        mload(PAIRING_PREAMBLE_SUCCESS_FLAG)\n                    ),\n                    mload(OPENING_COMMITMENT_SUCCESS_FLAG)\n                )\n            ) {\n                mstore(0x0, PROOF_FAILURE_SELECTOR)\n                revert(0x00, 0x04)\n            }\n            {\n                mstore(0x00, 0x01)\n                return(0x00, 0x20) // Proof succeeded!\n            }\n        }\n    }\n}\n\ncontract UltraVerifier is BaseUltraVerifier {\n    function getVerificationKeyHash()\n        public\n        pure\n        override(BaseUltraVerifier)\n        returns (bytes32)\n    {\n        return UltraVerificationKey.verificationKeyHash();\n    }\n\n    function loadVerificationKey(\n        uint256 vk,\n        uint256 _omegaInverseLoc\n    ) internal pure virtual override(BaseUltraVerifier) {\n        UltraVerificationKey.loadVerificationKey(vk, _omegaInverseLoc);\n    }\n}\n"
    },
    "lib/forge-std/src/console2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.4.22 <0.9.0;\n\n/// @dev The original console.sol uses `int` and `uint` for computing function selectors, but it should\n/// use `int256` and `uint256`. This modified version fixes that. This version is recommended\n/// over `console.sol` if you don't need compatibility with Hardhat as the logs will show up in\n/// forge stack traces. If you do need compatibility with Hardhat, you must use `console.sol`.\n/// Reference: https://github.com/NomicFoundation/hardhat/issues/2178\nlibrary console2 {\n    address constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n    function _castLogPayloadViewToPure(\n        function(bytes memory) internal view fnIn\n    ) internal pure returns (function(bytes memory) internal pure fnOut) {\n        assembly {\n            fnOut := fnIn\n        }\n    }\n\n    function _sendLogPayload(bytes memory payload) internal pure {\n        _castLogPayloadViewToPure(_sendLogPayloadView)(payload);\n    }\n\n    function _sendLogPayloadView(bytes memory payload) private view {\n        uint256 payloadLength = payload.length;\n        address consoleAddress = CONSOLE_ADDRESS;\n        /// @solidity memory-safe-assembly\n        assembly {\n            let payloadStart := add(payload, 32)\n            let r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n        }\n    }\n\n    function log() internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log()\"));\n    }\n\n    function logInt(int256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(int256)\", p0));\n    }\n\n    function logUint(uint256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n    }\n\n    function logString(string memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function logBool(bool p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function logAddress(address p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function logBytes(bytes memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n    }\n\n    function logBytes1(bytes1 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n    }\n\n    function logBytes2(bytes2 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n    }\n\n    function logBytes3(bytes3 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n    }\n\n    function logBytes4(bytes4 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n    }\n\n    function logBytes5(bytes5 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n    }\n\n    function logBytes6(bytes6 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n    }\n\n    function logBytes7(bytes7 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n    }\n\n    function logBytes8(bytes8 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n    }\n\n    function logBytes9(bytes9 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n    }\n\n    function logBytes10(bytes10 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n    }\n\n    function logBytes11(bytes11 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n    }\n\n    function logBytes12(bytes12 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n    }\n\n    function logBytes13(bytes13 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n    }\n\n    function logBytes14(bytes14 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n    }\n\n    function logBytes15(bytes15 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n    }\n\n    function logBytes16(bytes16 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n    }\n\n    function logBytes17(bytes17 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n    }\n\n    function logBytes18(bytes18 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n    }\n\n    function logBytes19(bytes19 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n    }\n\n    function logBytes20(bytes20 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n    }\n\n    function logBytes21(bytes21 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n    }\n\n    function logBytes22(bytes22 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n    }\n\n    function logBytes23(bytes23 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n    }\n\n    function logBytes24(bytes24 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n    }\n\n    function logBytes25(bytes25 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n    }\n\n    function logBytes26(bytes26 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n    }\n\n    function logBytes27(bytes27 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n    }\n\n    function logBytes28(bytes28 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n    }\n\n    function logBytes29(bytes29 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n    }\n\n    function logBytes30(bytes30 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n    }\n\n    function logBytes31(bytes31 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n    }\n\n    function logBytes32(bytes32 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n    }\n\n    function log(uint256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n    }\n\n    function log(int256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(int256)\", p0));\n    }\n\n    function log(string memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function log(bool p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function log(address p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function log(uint256 p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256)\", p0, p1));\n    }\n\n    function log(uint256 p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string)\", p0, p1));\n    }\n\n    function log(uint256 p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool)\", p0, p1));\n    }\n\n    function log(uint256 p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address)\", p0, p1));\n    }\n\n    function log(string memory p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256)\", p0, p1));\n    }\n\n    function log(string memory p0, int256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,int256)\", p0, p1));\n    }\n\n    function log(string memory p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n    }\n\n    function log(string memory p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n    }\n\n    function log(string memory p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n    }\n\n    function log(bool p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256)\", p0, p1));\n    }\n\n    function log(bool p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n    }\n\n    function log(bool p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n    }\n\n    function log(bool p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n    }\n\n    function log(address p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256)\", p0, p1));\n    }\n\n    function log(address p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n    }\n\n    function log(address p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n    }\n\n    function log(address p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n    }\n\n}"
    }
  },
  "settings": {
    "remappings": [
      "ds-test/=lib/forge-std/lib/ds-test/src/",
      "forge-std/=lib/forge-std/src/"
    ],
    "optimizer": { "enabled": true, "runs": 200 },
    "metadata": {
      "useLiteralContent": false,
      "bytecodeHash": "ipfs",
      "appendCBOR": true
    },
    "outputSelection": {
      "*": {
        "": ["ast"],
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata"
        ]
      }
    },
    "evmVersion": "paris",
    "libraries": {}
  }
}
